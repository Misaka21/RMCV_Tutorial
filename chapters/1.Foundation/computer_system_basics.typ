== 计算机系统基础

=== 为什么需要了解计算机系统
// 引言：从"能跑"到"跑得好"
// - 为什么程序会崩溃？为什么会卡顿？
// - 内存泄漏、死锁、性能瓶颈的根源
// - RoboMaster 实时系统对底层理解的要求
// - 本章与后续 C++ 内容的关联（内存管理、多线程、文件操作）

=== 程序的执行：从源码到运行
// 编译、链接、加载的过程
// - 预处理 → 编译 → 汇编 → 链接
// - 可执行文件的结构（代码段、数据段、BSS）
// - 程序加载到内存的过程
// - 静态链接与动态链接（.so/.dll）
// - 为什么 ROS 节点启动需要时间？

=== 进程：程序的运行实例
// 进程的概念与生命周期
// - 进程是什么：运行中的程序
// - 进程的状态（就绪、运行、阻塞、终止）
// - 进程控制块（PCB）与进程调度
// - 查看进程：ps, top, htop
// - 进程间通信（IPC）：管道、共享内存、消息队列、信号
// - ROS 节点本质上就是进程

=== 线程：轻量级执行单元
// 线程的概念与优势
// - 线程 vs 进程：共享地址空间
// - 为什么需要多线程：并发与并行
// - 用户线程与内核线程
// - 线程调度与上下文切换
// - 多线程的挑战：竞态条件、死锁
// - 引出 C++ std::thread

=== 内存层次结构
// 从寄存器到磁盘
// - 存储金字塔：寄存器 → 缓存 → 内存 → 磁盘
// - CPU 缓存的工作原理（L1/L2/L3）
// - 缓存命中与缓存未命中
// - 局部性原理：时间局部性、空间局部性
// - 为什么连续内存访问更快？（vector vs list 的真正原因）

=== 虚拟内存
// 内存的抽象与保护
// - 物理内存与虚拟内存
// - 地址空间：每个进程的"独立世界"
// - 页表与地址转换
// - 页面置换与缺页中断
// - 内存保护：为什么野指针会 Segmentation Fault
// - 内存映射文件（mmap）

=== 进程的内存布局
// 栈、堆与数据区
// - 代码段（text）：只读的机器指令
// - 数据段（data）：已初始化的全局/静态变量
// - BSS 段：未初始化的全局/静态变量
// - 堆（heap）：动态分配，向上增长，new/malloc
// - 栈（stack）：局部变量，向下增长，自动管理
// - 栈溢出与堆溢出
// - 为什么栈上分配比堆快？
// - 引出 C++ 智能指针的必要性

=== 文件系统
// 持久化存储的抽象
// - 文件与目录的概念
// - 文件描述符与文件表
// - Linux 文件系统层次结构（/home, /dev, /proc, /tmp）
// - 一切皆文件：设备文件、管道、套接字
// - 文件权限（rwx）与用户/组
// - 缓冲 I/O 与直接 I/O
// - 引出 C++ fstream

=== 网络通信基础
// 进程间的远程通信
// - OSI 七层模型与 TCP/IP 四层模型
// - IP 地址与端口号
// - TCP vs UDP：可靠 vs 快速
// - Socket 编程概念
// - 客户端-服务器模型
// - ROS 通信的底层：TCP/UDP
// - 为什么机器人通信经常用 UDP？

=== 并发与同步
// 多任务协作的挑战
// - 临界区与互斥
// - 原子操作
// - 锁的概念：互斥锁、读写锁、自旋锁
// - 信号量与条件变量
// - 死锁的四个条件与预防
// - 引出 C++ mutex, lock_guard, condition_variable

=== 操作系统的角色
// 硬件与软件的桥梁
// - 操作系统的核心功能：进程管理、内存管理、文件系统、设备驱动
// - 系统调用：用户态与内核态
// - 中断与异常处理
// - 实时操作系统（RTOS）vs 通用操作系统
// - 为什么 RoboMaster 嵌入式端常用 FreeRTOS？

=== 性能分析与调试工具
// 诊断系统问题
// - top/htop：CPU 和内存监控
// - strace：系统调用追踪
// - valgrind：内存泄漏检测
// - gdb：调试器基础
// - perf：性能分析
// - 如何定位机器人程序的性能瓶颈