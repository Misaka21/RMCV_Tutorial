#import "/template/template.typ": *

#show raw.where(block: true): set block(inset: (left: 4em))
=== C++ 程序结构与编译
// 添加编译相关：g++、CMake 简介
// Hello World、编译流程
本章节介绍 C++ 程序的基本组成形式，并说明源代码从编写到生成可执行文件的完整流程。内容包括程序结构、编译器 g++ 的使用方法以及构建系统 CMake 的基础用法。

一个最小的 C++ 程序通常由源文件`\*.cpp`和可选的头文件`\*.h 或 \*.hpp`组成。程序的入口由 `main()` 函数定义，它是操作系统加载程序后第一个执行的函数。

下面是一个简单的 C++ 程序示例：
```cpp
#include <iostream>                         // 引入输入输出库
using namespace std;                        // 使用标准命名空间
int main() {
    cout << "Hello, RoboMaster!" << endl;   // 输出文本
    return 0;                               // 返回状态码
}
```
如果读者此前已经接触过C语言，可以发现C++与C语言的相似之处，但必须说明的是：C++和C语言是两种不同的语言，C++既不是C语言的扩展，C语言也不是C++的简化。这一点将在后续的章节中越来越多地体现。对比C++与C语言的Hello World代码就能看出明显的区别，这是C语言的Hello World代码，能和上方代码输出相同的内容：

```c
#include <stdio.h>                          // 引入标准输入输出库
int main() {
    printf("Hello, RoboMaster!\n");         // 输出文本
    return 0;                               // 返回状态码
}
```
了解了C语言与C++的不同之后，现在让我们来解释一下这段程序：
- *`#include <iostream>`：*

C++ 提供了一组标准头文件（header files），这些头文件包含了常用的类型、函数和类，程序只需包含相应头文件即可直接使用这些工具。<iostream> 就是其中用于“输入/输出”操作的头文件：I/O（Input/Output）表示输入输出，stream（流）表示数据按序列化地在程序内部或程序与外部设备之间传输的抽象。


在本程序中，我们需要借助标准输出能力将文本打印到终端，`<iostream>`中正好提供了 `cout`、`cin`、`cerr` 等对象来完成这些工作。因此用 `#include <iostream>` 将相关声明引入到翻译单元中，编译器在预处理阶段会把头文件内容插入到源文件。

- *`using namespace std;`：*
C++ 使用命名空间（namespace）来组织符号，避免不同库之间的名称冲突。标准库中的大部分符号（包括 cout、endl、vector 等）都被放在 std 命名空间内。

`using namespace std;` 这行告诉编译器在当前作用域中可以不写 `std::` 前缀直接访问 `std` 下的符号。它方便了书写，但在较大型工程或头文件中滥用会增加命名冲突的风险。因此更推荐的做法是在需要时显式使用 `std::`：
```cpp
#include <iostream>

int main() {
    std::cout << "Hello World" << std::endl;
    return 0;
}
```
这样更清晰，也更安全。


- *`int main()`：*
每个可独立运行的 C++ 程序都必须包含一个名为 `main()` 的函数：操作系统在启动程序时会调用它。`main` 的返回值类型通常为 `int`，代表程序的退出状态；返回 `0` 一般表示成功，非零值表示出现了错误或异常终止。

函数体由一对大括号 `{}` 包围，内部是*语句块*（statement block），包含程序逻辑。

- *注释：`//` 与 `/* ... */`*
注释用于向阅读代码的人说明意图，编译器会忽略注释内容。C++ 支持两种注释形式：
    -- `//` 单行注释：`//` 之后至行尾为注释。
    -- `/* */` 多行注释：可跨行书写。

良好的注释能提高代码可读性，但注释内容应简洁、相关，避免重复说明代码本身能表达的事实。

- *`cout << "Hello World" << endl;`* —— 输出与“流”的概念
这一行展示了 C++ 标准库 I/O 的核心风格：*流*（stream）操作。*`cout`*（Console Output）是一个输出流对象，负责将数据发送到标准输出（通常是终端）。`<<` 是*插入运算符*（insertion operator），表示“把右侧的值插入到左侧的流中”，可把多个项连续插入同一个流。`"Hello World"` 是一个字符串字面量，将被写入 `cout`。`endl` 是一个操作符，表示输出换行并刷新流*缓冲区*（flush），常用于确保输出及时显示。流操作的链式写法使得多个输出项可以按顺序组合，例如：

```cpp
cout << "Hello" << " " << "World" << endl;
```

可以把这一过程理解为：字符串和 `endl` 按顺序“流向” `cout`，最终由 `cout` 将它们输出到终端。这个“流动”的抽象比直接调用格式化函数更面向对象，也更易于扩展（例如重载 `operator<<` 来支持自定义类型）。需要注意的一点是：`endl` 会强制刷新缓冲区，这在频繁输出的小段落中可能影响性能。若只需要换行而不刷新的话，可以使用 '\n'。

- *`return 0;`*

return 0; 表示 main 正常结束并向操作系统返回成功状态。不同平台和约定会使用特定的非零值标识各种错误或异常退出原因，但通常情况下返回 0 即视为成功。


下面介绍一下如何使用 g++ 编译器来编译和运行这个程序。将 C++ 源代码转换为可执行文件是一个多阶段的过程，主要包括四个步骤：预处理、编译、汇编、链接。
#{
  set par(first-line-indent: 0pt)
  [*预处理：*]
}
预处理器处理所有以 \# 开头的指令，主要工作包括：

  + 文件包含：将 `#include` 指定的头文件内容插入到源文件中
  + 宏展开：替换 `#define` 定义的宏
  + 条件编译：根据 `#ifdef`、`#ifndef` 等指令决定哪些代码参与编译


=== 变量与基本数据类型
// int, float, double, bool, char
// auto 关键字
// 类型转换

=== 运算符与表达式
// 算术、关系、逻辑运算符
// 运算符优先级

=== 控制语句
// if/else, switch
// for, while, do-while
// break, continue

=== 函数基础
// ⚠️ 提前到这里！
// 函数定义、参数、返回值
// 函数重载
// 内联函数

=== 数组与字符串
// C 风格数组
// std::array
// std::string 基础操作

=== 指针基础
// 指针概念、解引用
// 指针与数组
// 指针与函数参数

=== 引用
// 引用 vs 指针
// 引用作为函数参数
// 常量引用

=== 结构体
// struct 定义与使用
// 为"类"做铺垫

=== 类与对象
// class 定义
// 成员变量与成员函数
// 访问控制（public/private/protected）
// this 指针

=== 构造函数与析构函数
// 对象的生命周期
// 构造函数重载
// 初始化列表
// 析构函数
// RAII 思想

=== 拷贝控制
// 拷贝构造函数
// 拷贝赋值运算符
// 深拷贝 vs 浅拷贝

=== 类的继承
// 继承语法
// 访问控制
// 构造与析构顺序

=== 多态与虚函数
// 虚函数
// 纯虚函数与抽象类
// 虚析构函数
// 动态绑定

=== 运算符重载
// 单独成节，内容较多
// 常用运算符重载
// 友元函数

=== STL 容器
// vector, deque, list
// map, unordered_map
// set, unordered_set
// queue, stack
// 如何选择容器

=== STL 算法与迭代器
// 迭代器概念
// 常用算法（sort, find, transform）
// 范围 for 循环

=== Lambda 表达式
// ⚠️ 重要！ROS 回调常用
// Lambda 语法
// 捕获列表
// 应用场景

=== 智能指针
// unique_ptr
// shared_ptr
// weak_ptr
// 何时使用哪种

=== 右值引用与移动语义
// 可选/进阶
// std::move
// 移动构造函数

=== 多线程基础
// std::thread
// mutex 与 lock_guard
// 条件变量
// RoboMaster 多线程应用

=== 文件操作
// fstream
// 读写配置文件
// 日志记录

=== Eigen 矩阵库
// ⚠️ RoboMaster 必备
// 向量与矩阵运算
// 姿态表示（旋转矩阵、四元数）

=== OpenCV 基础
// ⚠️ 视觉必备
// 图像读取与显示
// 颜色空间转换
// 基本图像操作

=== 串口通信
// ⚠️ 与下位机通信
// serial 库使用
// 数据封装与解析