
#show raw.where(block: true): set block(inset: (left: 4em))
=== Linux 的前世今生
// 从 Unix 到 Linux 的历史脉络
// - Unix 的诞生（1969，贝尔实验室，Ken Thompson & Dennis Ritchie）
// - Unix 哲学：小而美、组合、文本流
// - Unix 的分裂与商业化
// - Richard Stallman 与 GNU 计划（1983）
// - 自由软件运动与 GPL 协议
// - Linus Torvalds 与 Linux 内核（1991）
// - "I'm doing a (free) operating system (just a hobby)"
// - Linux 内核 + GNU 工具 = 完整操作系统
// - 开源社区的力量：从爱好项目到主导世界
// === Linux 的前世今生

在开始学习 Linux 的具体操作之前，了解它的历史背景会帮助你更好地理解这个系统的设计理念。Linux 不是凭空出现的，它继承了 Unix 数十年的智慧，融合了自由软件运动的理想，最终在全球开发者的协作下成长为今天这个无处不在的操作系统。这段历史不仅仅是技术的演进，更是一群人对"软件应该如何被创造和分享"这个问题的回答。

==== Unix：一切的起源

故事要从 1969 年说起。那一年，人类首次登上月球，而在美国新泽西州的贝尔实验室，两位计算机科学家 Ken Thompson 和 Dennis Ritchie 正在做一件同样具有开创性的事情——他们在一台被闲置的 PDP-7 小型机上，开发一个全新的操作系统。这个系统后来被命名为 Unix。

Unix 的诞生带有几分偶然。在此之前，贝尔实验室参与了一个名为 Multics 的大型操作系统项目，但这个项目因为过于复杂而进展缓慢，贝尔实验室最终选择退出。Thompson 和 Ritchie 对 Multics 的一些理念仍然着迷，于是决定自己动手，用更简洁的方式实现类似的功能。Unix 这个名字本身就是对 Multics 的一种调侃——Multics 意为"多路复用"，而 Unix 则暗示"单一"，讽刺 Multics 的过度复杂。

Unix 的设计体现了一种独特的哲学，这种哲学至今仍深刻影响着软件开发的方式。其核心理念可以概括为几个原则：每个程序只做一件事，并把它做好；程序之间通过文本流协作，一个程序的输出可以作为另一个程序的输入；尽早编写原型，快速迭代改进。这种"小而美"的设计思想与当时流行的"大而全"的系统形成鲜明对比。当你在 Linux 终端中用管道符 `|` 将多个命令串联起来时，你正在使用的就是 Unix 哲学的直接体现。

1972 年，Dennis Ritchie 完成了另一项影响深远的工作——他发明了 C 语言，并用 C 语言重写了 Unix。这使得 Unix 成为第一个主要用高级语言编写的操作系统，大大提高了它的可移植性。在此之前，操作系统通常用汇编语言编写，与特定硬件紧密绑定。C 语言的出现让 Unix 可以相对容易地移植到不同的计算机上，这为它后来的广泛传播奠定了基础。

贝尔实验室隶属于 AT&T 公司，当时 AT&T 受到反垄断法规的限制，不能进入计算机业务，因此以极低的成本将 Unix 授权给大学和研究机构。这使得 Unix 在学术界迅速流行起来。加州大学伯克利分校的学生和研究人员在 Unix 的基础上进行了大量改进和扩展，形成了著名的 BSD（Berkeley Software Distribution）版本。许多我们今天仍在使用的网络功能，包括 TCP/IP 协议栈的实现，都源自 BSD。

然而，好景不长。1984 年，AT&T 被拆分后获准进入计算机市场，Unix 开始商业化，授权费用大幅上涨。与此同时，各个公司和机构开发的 Unix 变体开始分化，互不兼容。这个时期出现了许多商业 Unix 系统：Sun 的 Solaris、IBM 的 AIX、HP 的 HP-UX 等。Unix 世界陷入了碎片化和专利诉讼的泥潭，曾经开放共享的精神逐渐消失。

==== GNU 与自由软件运动

在 Unix 走向封闭的同时，一位 MIT 人工智能实验室的程序员决定反抗这一趋势。他的名字是 Richard Stallman，人们通常称他为 RMS。

Stallman 是一位极具原则性的人。在他看来，软件应该是自由的——用户应该有权运行、研究、修改和分发软件。商业公司将软件封闭起来、禁止用户查看和修改源代码的做法，在他眼中是对用户自由的侵犯。他常常讲述一个故事：实验室的打印机经常卡纸，如果能看到驱动程序的源代码，他可以轻松添加一个卡纸通知功能；但新打印机的驱动程序是闭源的，他无能为力。这种"被软件控制而无法控制软件"的无力感，促使他下定决心做出改变。

1983 年，Stallman 发起了 GNU 计划。GNU 是"GNU's Not Unix"的递归缩写——一个典型的黑客式幽默。这个计划的目标是创建一个完全自由的、与 Unix 兼容的操作系统。所谓"自由"，Stallman 定义了四项基本自由：自由运行程序、自由研究程序如何工作（需要源代码）、自由分发程序的副本、自由改进程序并发布改进版本。注意，这里的"自由"（free as in freedom）不是"免费"（free as in free beer）的意思，尽管自由软件通常也是免费的。

1985 年，Stallman 创立了自由软件基金会（Free Software Foundation，FSF），并发明了 GPL（GNU General Public License）许可证。GPL 的核心条款是"copyleft"——如果你分发基于 GPL 软件的衍生作品，你必须以同样的 GPL 条款发布，包括提供源代码。这确保了自由软件的自由能够传递下去，不会被人拿去变成专有软件。

在接下来的几年里，GNU 计划开发了大量高质量的软件工具：GCC 编译器、GDB 调试器、Emacs 编辑器、GNU Make、Bash Shell，以及众多的命令行工具（ls、cat、grep 等）。这些工具至今仍是 Linux 系统的核心组成部分，也是每个 RoboMaster 开发者每天都在使用的工具。你用 `g++` 编译代码、用 `make` 构建项目、用 `bash` 编写脚本，使用的都是 GNU 软件。

然而，到了 1990 年代初，GNU 计划仍然缺少一个关键组件——操作系统内核。Stallman 团队正在开发一个名为 GNU Hurd 的内核，但由于采用了过于前卫的微内核架构，开发进度非常缓慢（事实上，Hurd 至今仍未完成）。GNU 拥有了构建完整操作系统所需的几乎所有工具，却唯独缺少让这些工具运行起来的内核。这就像拥有了所有的汽车零件，却没有发动机。

==== Linux 内核的诞生

1991 年 8 月 25 日，芬兰赫尔辛基大学的一名 21 岁学生在 Usenet 新闻组发布了一条消息：

> Hello everybody out there using minix -
>
> I'm doing a (free) operating system (just a hobby, won't be big and professional like gnu) for 386(486) AT clones.

这个学生的名字是 Linus Torvalds，他正在开发的这个"业余爱好项目"，就是后来的 Linux 内核。

Torvalds 开发 Linux 的初衷很简单：他想在自己新买的 386 电脑上运行 Unix，但商业 Unix 太贵，适合教学的 Minix 系统功能又太弱。于是他决定自己写一个。与 Stallman 的理想主义不同，Torvalds 的动机更加实用——他只是想要一个好用的系统。

Linux 的开发速度令人惊讶。Torvalds 将源代码发布在网上，邀请其他人参与改进。来自世界各地的程序员通过互联网协作，报告 bug、提交补丁、添加新功能。这种分布式协作开发的模式在当时是前所未有的。Torvalds 后来将 Linux 内核以 GPL 许可证发布，正式加入了自由软件的阵营。

Linux 内核与 GNU 工具的结合，终于形成了一个完整的自由操作系统。严格来说，我们日常使用的"Linux"应该称为"GNU/Linux"——它使用 Linux 内核，但用户空间的大部分工具来自 GNU 计划。Stallman 一直坚持这个称呼，以强调 GNU 项目的贡献，但在日常使用中，人们通常简称为"Linux"。

Linux 的成功有多重因素。技术上，它采用了成熟的单内核（monolithic kernel）架构，性能优异且稳定。许可证上，GPL 保证了代码的开放性，任何人都可以自由使用和修改。时机上，互联网的兴起让全球协作成为可能，也创造了对可靠服务器操作系统的巨大需求。社区上，Torvalds 的务实态度和技术领导力吸引了大量优秀的贡献者。

==== 从爱好项目到主导世界

如果 1991 年的 Torvalds 能够预见 Linux 的未来，他一定会惊讶不已。三十多年后的今天，Linux 已经成为世界上最成功的操作系统之一：

全球大多数的服务器运行着 Linux，包括支撑互联网运转的网站、云服务和数据中心。当你使用搜索引擎、观看在线视频或者发送消息时，你的请求几乎必然是由某个 Linux 服务器处理的。

世界上最快的 500 台超级计算机，100% 运行 Linux。科学研究、气象预测、人工智能训练，这些需要巨大计算能力的任务，都依赖于 Linux。

Android 系统基于 Linux 内核，这意味着全球数十亿部智能手机都在运行 Linux 的变体。

嵌入式领域同样是 Linux 的天下。从路由器、智能电视到汽车信息娱乐系统，从树莓派到 NVIDIA Jetson，Linux 无处不在。RoboMaster 机器人上常用的 Jetson 系列计算平台，运行的正是基于 Ubuntu 的 Linux 系统。

如今，Linux 内核的开发已经成为人类历史上最大规模的协作项目之一。数以千计的开发者来自数百家公司，包括 Google、Microsoft、Intel、Red Hat、华为等，共同贡献代码。曾经对 Linux 嗤之以鼻的微软，现在不仅是内核的主要贡献者之一，还在 Windows 中集成了 WSL（Windows Subsystem for Linux），让用户可以在 Windows 上直接运行 Linux 程序。

Linux 的成功证明了开源协作模式的力量。一个芬兰大学生的业余项目，在全球开发者的共同努力下，成长为支撑现代数字世界的基础设施。当你开始学习 Linux，你不仅是在学习一个操作系统的使用方法，更是在加入一个拥有数十年历史、影响深远的技术传统。Unix 的设计哲学、GNU 的自由精神、全球社区的协作文化——这些都将在你的学习和实践中逐渐体现。

对于 RoboMaster 开发者来说，理解这段历史还有另一层意义。机器人开发所依赖的几乎所有核心工具——ROS、OpenCV、GCC、CMake、Git——都是开源软件，都植根于 Linux 和自由软件的传统。当你使用这些工具时，你是这个庞大开源生态的受益者；当你有朝一日贡献自己的代码时，你也将成为这个传统的一部分。


=== 为什么 RoboMaster 开发选择 Linux
// 机器人开发者的必然选择
// - ROS/ROS2 原生运行在 Linux 上
// - 开源生态：OpenCV、PCL、Eigen 等库的最佳支持
// - 实时性与性能：更好的系统控制能力
// - 嵌入式友好：树莓派、Jetson 都运行 Linux
// - 服务器主导：部署、仿真环境
// - 开发工具链完善：GCC、GDB、CMake
// - 免费且可定制
// - 学习 Linux 是程序员的必备技能
// === 为什么 RoboMaster 开发选择 Linux

如果你观察 RoboMaster 各战队的技术栈，会发现一个有趣的现象：几乎所有队伍的视觉系统、导航算法、仿真环境都运行在 Linux 上。这不是偶然的选择，也不是因为开发者们故意追求"极客感"。Linux 之所以成为机器人开发的主流平台，是多种因素共同作用的结果。理解这些原因，可以帮助你更好地认识 Linux 在机器人领域的地位，也能让你在学习过程中保持动力——毕竟，你学习的是一项在行业中真正被广泛使用的技能。

==== ROS 生态的天然选择

机器人操作系统 ROS（Robot Operating System）是机器人软件开发的事实标准。无论是学术研究还是工业应用，ROS 都占据着主导地位。RoboMaster 的许多队伍使用 ROS 2 来构建他们的软件系统，实现模块化的节点通信、坐标变换、传感器数据处理等功能。

ROS 从诞生之日起就是为 Linux 设计的。虽然 ROS 2 在技术上支持 Windows 和 macOS，但这种支持更多是"能用"而非"好用"的级别。许多 ROS 包只在 Linux 上经过充分测试，一些底层功能（如实时调度、共享内存通信）在 Linux 上的实现也更加成熟。当你在 Windows 上遇到 ROS 相关的问题时，往往很难找到解决方案，因为社区里几乎所有人都在使用 Linux。选择 Linux，意味着你站在了最大的用户群体中，遇到问题时更容易获得帮助。

更重要的是，ROS 的整个工具链——catkin、colcon、rosdep、roslaunch——都是围绕 Linux 的命令行环境设计的。在 Linux 上，你可以用简单的几条命令完成工作空间的创建、依赖的安装、包的构建。这种流畅的开发体验是其他平台难以复制的。

==== 开源库的最佳支持

机器人开发离不开大量的开源库。OpenCV 处理图像，Eigen 进行矩阵运算，PCL 处理点云，Ceres 解决优化问题，g2o 构建图优化——这些库构成了机器人算法的基础设施。虽然这些库大多是跨平台的，但它们在 Linux 上的支持通常是最好的。

以 OpenCV 为例，在 Linux 上你可以通过包管理器一键安装，也可以从源码编译并启用各种优化选项（如 CUDA、OpenCL、TBB）。编译过程通常很顺利，因为库的开发者自己就在 Linux 上工作。而在 Windows 上，你可能需要折腾 Visual Studio 的版本兼容性、处理各种路径问题、手动配置环境变量。这些额外的麻烦会消耗大量时间，而这些时间本可以用来专注于算法本身。

Linux 的包管理系统也让依赖管理变得简单。`apt install libopencv-dev` 一条命令就能安装 OpenCV 及其所有依赖。在 ROS 2 中，`rosdep install` 可以自动解析并安装包的所有依赖。这种自动化的依赖管理在 Windows 上是很难实现的，你往往需要手动下载、配置每一个库。

==== 实时性与系统控制

机器人是一个实时系统，传感器数据需要及时处理，控制指令需要准时发送。虽然 RoboMaster 比赛对实时性的要求不如工业机器人那么严格，但低延迟和确定性的响应时间仍然很重要。一个视觉系统如果偶尔出现几十毫秒的卡顿，可能就会错过移动目标。

Linux 在实时性方面有显著优势。通过 PREEMPT_RT 补丁，Linux 可以被配置为硬实时操作系统。即使不使用实时补丁，Linux 的调度器也提供了多种调度策略（如 SCHED_FIFO、SCHED_RR），允许关键线程获得更高的优先级。开发者可以精细控制内存锁定、CPU 亲和性、中断处理，这些在 Windows 上要么不可能，要么需要特殊的驱动和权限。

Linux 还提供了对系统底层的完全访问权限。你可以直接操作串口、GPIO、I2C、SPI 等硬件接口，不需要安装额外的驱动程序。当你需要调试性能问题时，perf、strace、ltrace 等工具可以帮助你深入理解程序的行为。这种透明度和可控性是机器人开发所需要的。

==== 嵌入式平台的统一

RoboMaster 机器人上运行代码的硬件往往不是普通的 PC。树莓派、NVIDIA Jetson、各种工控机——这些嵌入式平台几乎都运行 Linux。Jetson 系列使用基于 Ubuntu 的 JetPack 系统，树莓派官方系统 Raspberry Pi OS 基于 Debian，大多数工控机预装的也是 Linux 发行版。

在同一个操作系统家族中开发意味着代码的可移植性大大提高。你在自己的 Ubuntu 笔记本上开发和测试的代码，可以几乎不做修改地部署到 Jetson 上运行。环境配置、依赖安装、构建流程都是相似的。如果你在 Windows 上开发，然后部署到 Linux 嵌入式平台，就需要处理跨平台的各种差异，这增加了不必要的复杂性。

使用 Linux 进行开发还意味着你可以在本地模拟目标环境。通过 Docker 容器或虚拟机，你可以在开发机上创建一个与目标平台相同的环境，确保代码在部署前就经过充分测试。这种开发和部署环境的一致性是高效工作流程的基础。

==== 仿真与持续集成

现代机器人开发离不开仿真环境。Gazebo、Isaac Sim、Webots 等仿真器让你可以在虚拟环境中测试算法，不需要真实的机器人硬件。这对于 RoboMaster 开发尤其重要——你不可能 24 小时都能接触到机器人，但你可以随时在仿真环境中运行和调试代码。

这些仿真器在 Linux 上的支持是最好的。Gazebo 就是为 Linux 开发的，虽然也支持其他平台，但许多高级功能（如 ROS 集成、GPU 加速渲染）在 Linux 上最稳定。NVIDIA 的 Isaac Sim 虽然也支持 Windows，但官方文档和教程主要针对 Linux。

持续集成（CI）是软件工程的重要实践，机器人开发也不例外。GitHub Actions、GitLab CI 等 CI 平台的默认环境都是 Linux。当你的代码推送到仓库时，CI 系统会自动在 Linux 容器中构建和测试。如果你的项目只在 Windows 上能构建，就无法利用这些便利的自动化工具。

==== 开发工具链的成熟

C++ 是机器人开发的主要语言，而 Linux 提供了最成熟的 C++ 开发工具链。GCC 和 Clang 是两个主流的开源编译器，它们在 Linux 上的支持最为完善，对最新 C++ 标准的实现也最快。CMake 虽然是跨平台的，但它的设计哲学和 Linux 的命令行文化更加契合。

调试工具同样如此。GDB 是最强大的命令行调试器，在 Linux 上可以与各种 IDE 无缝集成。Valgrind 用于检测内存泄漏，AddressSanitizer 和 ThreadSanitizer 用于发现内存和线程错误，这些工具在 Linux 上的支持都是最好的。当你的机器人程序出现难以复现的崩溃或内存问题时，这些工具可能是你唯一的救星。

性能分析工具也是 Linux 的强项。perf 可以进行 CPU 性能分析，gperftools 可以进行堆内存分析，FlameGraph 可以生成直观的火焰图。这些工具帮助你找到程序的性能瓶颈，在资源受限的嵌入式平台上尤为重要。

==== 免费、开源与可定制

对于学生团队来说，成本是一个现实的考虑因素。Linux 是免费的，你可以在任意数量的机器上安装和使用它，不需要担心许可证问题。相比之下，Windows 的正版授权对于多台开发机和机器人平台来说是一笔不小的开支。

开源意味着透明。当你遇到系统层面的问题时，可以查看源代码，理解系统的行为，甚至修改它。这在调试底层问题时非常有价值。你也可以根据需要定制系统，移除不需要的组件，优化启动时间和资源占用。在资源受限的嵌入式平台上，这种定制能力尤其重要。

开源社区的力量也不可忽视。Linux 有着庞大而活跃的社区，遇到问题时你可以在论坛、Stack Overflow、GitHub Issues 上找到帮助。许多问题已经有人遇到过并分享了解决方案。这种集体智慧是闭源系统无法比拟的。

==== 职业发展的投资

学习 Linux 不仅仅是为了 RoboMaster 比赛。从更长远的角度看，Linux 技能是软件工程师的必备素养。无论你将来从事机器人开发、后端开发、嵌入式系统还是云计算，都会用到 Linux。服务器世界几乎完全由 Linux 主导，Android 系统基于 Linux 内核，大多数 IoT 设备运行 Linux。

在 RoboMaster 的开发过程中学习 Linux，是一种自然而高效的学习方式。你不是为了学习而学习，而是为了解决实际问题而学习。这种目标驱动的学习往往更加深入和持久。当你毕业时，你不仅有比赛经历，还有扎实的 Linux 技能，这在求职时是一个显著的优势。

综合来看，选择 Linux 进行 RoboMaster 开发不是一种偏好，而是一种务实的选择。它让你能够使用最好的工具、获得最广泛的支持、与目标平台保持一致，同时为未来的职业发展打下基础。接下来的章节将带你从零开始，逐步掌握 Linux 的使用和开发技能。不要担心学习曲线——每一个现在熟练使用 Linux 的开发者，都曾经是从完全不懂开始的。重要的是迈出第一步，然后持续学习和实践。


=== Linux 与 Windows 的差异
// 两种不同的设计哲学
// - 开源 vs 闭源
// - 文件系统差异：目录树 vs 盘符
// - 路径分隔符：/ vs \
// - 大小写敏感 vs 不敏感
// - 可执行文件：无扩展名要求 vs .exe
// - 软件安装：包管理器 vs 安装向导
// - 命令行文化 vs 图形界面文化
// - 权限模型差异
// - 系统配置：文本文件 vs 注册表
// - "一切皆文件"的哲学
// - 常见的适应期困惑与解决
// === Linux 与 Windows 的差异

从 Windows 转向 Linux 的开发者往往会经历一段适应期。两个系统看起来都是操作系统，都能运行程序、管理文件，但它们的设计哲学和使用方式有着根本的不同。理解这些差异不仅能帮助你更快地适应 Linux，还能让你理解为什么 Linux 会以某种方式工作。本节将深入对比两个系统的核心差异，帮助你建立正确的心智模型。

==== 开源与闭源：根本的哲学分歧

Linux 和 Windows 最根本的区别在于它们的开发模式。Windows 是微软的商业产品，其源代码是保密的。你只能使用微软提供的功能，无法查看系统内部的工作原理，遇到问题时只能等待微软发布补丁。这种模式有其优点——统一的质量控制、商业支持、向后兼容性保证——但也意味着用户对系统的控制是有限的。

Linux 则完全不同。Linux 内核和大多数 Linux 软件都是开源的，任何人都可以查看、修改、分发源代码。这种开放性带来了几个重要的后果。首先，透明度意味着安全性。安全研究者可以审计代码，发现并修复漏洞，没有"安全靠隐藏"的问题。其次，你可以真正理解系统的工作原理。当程序出现问题时，你可以查看源代码，追踪问题的根源。第三，社区驱动的开发意味着软件会朝着用户需要的方向发展，而不是商业利益驱动的方向。

对于开发者来说，开源意味着学习的机会。你使用的每一个工具——编译器、调试器、库——都可以查看它的实现。这是一个巨大的学习资源，也是开源精神对技术社区的馈赠。

==== 文件系统：目录树与盘符

打开 Windows 的文件资源管理器，你会看到 C:、D:、E: 这样的盘符。每个物理磁盘或分区都有自己的盘符，文件路径以盘符开头，如 `C:\Users\Username\Documents\file.txt`。这种设计直观地反映了物理存储结构，但也带来了一些问题：程序需要知道文件在哪个盘符上，移动硬盘会改变盘符，不同机器上的路径可能不同。

Linux 采用了完全不同的设计：单一的目录树。整个文件系统从根目录 `/` 开始，所有文件和目录都是这棵树的一部分。没有盘符的概念，物理磁盘和分区通过"挂载"的方式接入到目录树的某个位置。例如，一个 USB 驱动器可能被挂载到 `/media/usb`，之后你就可以通过这个路径访问它的内容。文件路径看起来像 `/home/username/documents/file.txt`。

这种设计的优雅之处在于统一性。无论是本地硬盘、网络驱动器、USB 设备还是虚拟文件系统，它们都以相同的方式呈现在目录树中。程序不需要关心文件实际存储在哪个物理设备上，只需要知道路径。这种抽象让很多事情变得简单——你可以把一个慢速的本地目录替换成高速的网络存储，而程序完全不需要修改。

Linux 的目录结构遵循文件系统层次标准（FHS），主要目录各有用途：`/home` 存放用户文件，`/etc` 存放配置文件，`/usr` 存放系统程序和库，`/var` 存放可变数据如日志，`/tmp` 存放临时文件。刚开始可能觉得复杂，但熟悉之后你会发现这种组织方式非常合理——你总是知道去哪里找什么。

==== 路径分隔符与大小写敏感

一个看似微小但经常引起问题的差异是路径分隔符。Windows 使用反斜杠 `\`，Linux 使用正斜杠 `/`。这个差异源于历史原因——早期 DOS 使用 `/` 作为命令行选项的前缀（类似 Linux 的 `-`），所以选择了 `\` 作为路径分隔符。

对于开发者来说，这个差异意味着你需要注意代码中的路径处理。硬编码 `\` 的路径在 Linux 上无法工作，反之亦然。好的做法是使用编程语言提供的路径处理函数（如 Python 的 `os.path.join` 或 C++ 的 `std::filesystem::path`），让程序自动处理路径分隔符的差异。在 CMake 中，无论在什么平台上，都应该使用正斜杠 `/`，CMake 会自动转换。

另一个重要差异是大小写敏感性。在 Windows 上，`File.txt`、`file.txt` 和 `FILE.TXT` 指向同一个文件。在 Linux 上，它们是三个完全不同的文件。这个差异经常让从 Windows 转来的开发者踩坑：代码中 `#include "MyHeader.h"` 在 Windows 上能工作，但如果实际文件名是 `myheader.h`，在 Linux 上就会编译失败。

大小写敏感性也影响命令和程序名。在 Linux 上，`ls` 和 `LS` 是不同的命令（后者通常不存在）。`make` 和 `Make` 是不同的程序。这种设计更加精确——你想要什么就得明确说什么——但也需要更加仔细。养成统一使用小写文件名的习惯可以避免很多问题。

==== 可执行文件与权限

在 Windows 上，可执行文件通过扩展名来识别：`.exe`、`.bat`、`.cmd`、`.msi` 等。双击一个 `.exe` 文件就会运行它。这种方式简单直观，但也带来了安全隐患——恶意软件可以伪装成其他类型的文件（如 `photo.jpg.exe`），利用 Windows 默认隐藏扩展名的设置欺骗用户。

Linux 采用了完全不同的方式：文件是否可执行由其权限决定，而不是扩展名。一个文件要能够执行，必须具有"可执行"权限位。你可以用 `chmod +x script.sh` 给文件添加可执行权限，用 `chmod -x program` 移除可执行权限。扩展名只是给人看的提示，对系统没有任何意义。一个没有扩展名的文件完全可以是可执行程序，一个叫 `data.txt` 的文件如果有可执行权限也可以运行（虽然内容必须是有效的程序或脚本）。

这种设计更加安全。文件不会因为有某个扩展名就自动变得可执行。用户必须显式地赋予执行权限，这提供了一层额外的保护。同时，这种设计也更加灵活——可执行程序不需要遵循特定的命名约定。

Linux 的权限系统远比 Windows 复杂和强大。每个文件有三组权限：所有者（owner）、所属组（group）、其他人（others）。每组权限包括读（r）、写（w）、执行（x）三种。你会看到类似 `-rwxr-xr-x` 这样的权限字符串，表示所有者可以读写执行，组成员和其他人可以读和执行但不能写。理解和管理权限是 Linux 系统管理的基础技能，我们会在后面的章节详细介绍。

==== 软件安装：包管理器的革命

在 Windows 上安装软件，你需要找到软件的官网，下载安装程序，运行安装向导，一路点击"下一步"，可能还要处理各种捆绑软件的选项。卸载软件时，你要去控制面板找到程序，运行卸载程序，祈祷它能完全清理干净。更新软件？每个程序有自己的更新机制，有的会弹窗提示，有的需要手动检查。

Linux 的包管理器彻底改变了这一切。Ubuntu 使用 `apt`，Fedora 使用 `dnf`，Arch 使用 `pacman`——虽然命令不同，但理念相同：软件从中央仓库安装，依赖自动解决，更新一键完成。

```bash
# 安装软件（Ubuntu/Debian）
sudo apt install vlc

# 安装多个软件
sudo apt install git cmake build-essential

# 更新所有软件
sudo apt update && sudo apt upgrade

# 卸载软件
sudo apt remove vlc

# 搜索软件
apt search video player
```

包管理器的优势是全方位的。首先，安装过程简单且一致。不需要去各个网站下载，不需要点击安装向导，一条命令就完成了。其次，依赖管理是自动的。如果你要安装的软件需要其他库，包管理器会自动安装所有依赖。第三，更新是集中的。一条命令就能更新系统上的所有软件，包括操作系统本身。第四，卸载是干净的。包管理器知道软件安装了哪些文件，可以完全移除它们。

这种模式也带来了安全性的提升。软件来自官方维护的仓库，经过了审核和签名验证。你不会不小心从钓鱼网站下载到带病毒的安装程序。当软件有安全更新时，只需要运行系统更新，所有软件都会被更新到安全版本。

当然，包管理器也有局限性。仓库中的软件可能不是最新版本（为了稳定性），某些专有软件可能不在仓库中。这时你可能需要添加第三方仓库、使用 Flatpak/Snap 等通用包格式，或者从源码编译。但对于大多数日常使用和开发需求，官方仓库中的软件已经足够。

==== 命令行文化

Windows 的设计哲学是"图形界面优先"。大多数操作都可以通过点击鼠标完成，命令行（cmd 或 PowerShell）虽然存在，但更多是给高级用户使用的。普通用户可能从来不需要打开命令行窗口。

Linux 的传统正好相反：命令行是核心，图形界面是可选的附加层。许多 Linux 服务器根本没有安装图形界面，管理员通过 SSH 远程登录，用命令行完成所有操作。即使在桌面 Linux 上，许多任务用命令行完成也比图形界面更高效。

这种差异不是偶然的。命令行有一些图形界面难以替代的优势。首先是自动化：你可以把一系列命令写成脚本，一键执行复杂的操作序列。其次是可重复性：命令可以被记录、分享、版本控制，别人可以精确复现你的操作。第三是远程操作：通过 SSH，你可以在家里管理机房里的服务器，只需要一个终端窗口和网络连接。第四是精确控制：命令行提供了图形界面不一定暴露的选项，让你可以精确控制程序的行为。

对于 RoboMaster 开发来说，命令行技能尤为重要。ROS 2 的工作空间管理、包构建、节点运行都主要通过命令行进行。Git 版本控制虽然有图形界面工具，但命令行提供了更完整的功能。调试程序时，GDB 命令行调试器是最强大的工具。在机器人上排查问题时，你通常只能通过 SSH 连接，只有命令行可用。

不要把命令行看作障碍，而要把它看作一种强大的工具。一旦熟练掌握，你会发现命令行让很多任务变得更快、更简单。而且，命令行技能是可迁移的——无论你使用什么 Linux 发行版，基本的命令都是相同的。

==== 系统配置：文本文件与注册表

在 Windows 上，系统和程序的配置大多存储在注册表（Registry）中。注册表是一个层次化的数据库，存储了从系统设置到应用程序偏好的各种配置。要查看或修改注册表，你需要使用专门的编辑器（regedit），而且必须非常小心——错误的修改可能导致系统无法启动。注册表的结构复杂，路径冗长，普通用户几乎不会直接与之交互。

Linux 采用了截然不同的方式：配置存储在普通的文本文件中。系统配置在 `/etc` 目录下，用户配置在用户主目录的隐藏文件（以 `.` 开头的文件）中。例如，网络配置在 `/etc/network/interfaces` 或 `/etc/netplan/` 下，SSH 服务器配置在 `/etc/ssh/sshd_config`，用户的 shell 配置在 `~/.bashrc`。

这种设计的优势是显而易见的。文本文件可以用任何文本编辑器查看和修改，不需要专门的工具。文件有清晰的注释说明每个选项的含义，学习配置语法比学习注册表结构容易得多。你可以轻松备份配置文件，用版本控制跟踪配置的变化，把配置从一台机器复制到另一台机器。当配置出错时，文件格式通常比注册表更容易恢复。

对于开发者来说，文本配置文件意味着你可以用脚本自动化配置过程。需要在多台机器上进行相同的配置？写一个脚本，把配置文件复制过去即可。需要根据环境动态生成配置？用模板引擎生成文本文件。这种灵活性在 Windows 的注册表模型下是很难实现的。

当然，文本配置文件也有缺点。格式不统一——有的是 INI 格式，有的是 YAML，有的是自定义格式。语法错误可能导致服务无法启动。配置分散在多个文件中，需要知道去哪里找。但总的来说，文本配置的优点远大于缺点，特别是对于需要精细控制系统的开发者和管理员。

==== "一切皆文件"的哲学

Unix/Linux 有一个著名的设计原则："一切皆文件"（Everything is a file）。这不仅仅是一句口号，而是深刻影响系统设计的核心理念。在 Linux 中，几乎所有东西都可以用文件的方式来访问和操作。

硬件设备是文件。磁盘在 `/dev/sda`，分区在 `/dev/sda1`，串口在 `/dev/ttyUSB0`，摄像头在 `/dev/video0`。你可以像读写普通文件一样与这些设备交互。想要从串口读取数据？`cat /dev/ttyUSB0`。想要向设备发送数据？`echo "command" > /dev/ttyUSB0`。这种统一的接口让设备操作变得简单和一致。

进程信息是文件。`/proc` 目录包含了系统中所有进程的信息。`/proc/1234/status` 显示进程 1234 的状态，`/proc/1234/cmdline` 显示它的命令行，`/proc/1234/fd/` 目录列出了它打开的所有文件描述符。系统信息也在这里：`/proc/cpuinfo` 显示 CPU 信息，`/proc/meminfo` 显示内存使用情况。监控工具如 `top` 和 `htop` 就是通过读取 `/proc` 中的文件来获取信息的。

系统参数是文件。`/sys` 目录提供了对内核参数的访问。你可以读取文件来查询系统状态，写入文件来修改参数。例如，`/sys/class/backlight/intel_backlight/brightness` 控制屏幕亮度，向它写入数值就可以调整亮度。

这种设计的美妙之处在于统一性。无论你要做什么——读取传感器数据、查询系统状态、配置内核参数——都使用相同的操作：打开文件、读取或写入、关闭文件。不需要学习各种专门的 API，标准的文件操作就足够了。这大大简化了系统编程，也让 shell 脚本能够完成复杂的系统管理任务。

对于 RoboMaster 开发来说，这个哲学有实际的应用。与串口通信？打开 `/dev/ttyUSB0` 文件，用标准的读写操作进行通信。读取相机帧？打开 `/dev/video0`，用 V4L2 API（但底层还是文件操作）。监控系统资源？读取 `/proc` 和 `/sys` 中的文件。这种统一的模型让开发变得更加简单和一致。

==== 适应期的常见困惑

从 Windows 转向 Linux 时，有一些常见的困惑和问题。了解这些可以帮助你更快地适应。

"软件去哪里安装了？" 这是新手常问的问题。在 Windows 上，程序通常在 `C:\Program Files` 或 `C:\Program Files (x86)`。在 Linux 上，通过包管理器安装的程序分散在多个目录中：可执行文件在 `/usr/bin`，库在 `/usr/lib`，配置在 `/etc`，文档在 `/usr/share/doc`。这种分散看起来混乱，但实际上是有组织的——相同类型的文件放在一起，而不是相同程序的文件放在一起。你不需要关心程序装在哪里，只需要知道运行它的命令。

"怎么运行程序？" 在 Windows 上双击图标，在 Linux 上...取决于情况。如果程序在系统路径中，直接在终端输入命令即可。如果是当前目录下的程序，需要加 `./` 前缀，如 `./my_program`，这是一个安全特性，防止当前目录下的程序覆盖系统命令。如果程序没有执行权限，先用 `chmod +x` 添加权限。

"驱动程序在哪里下载？" 大多数情况下，你不需要。Linux 内核包含了大量硬件的驱动程序，即所谓的"开箱即用"。插入 USB 设备、连接打印机，系统通常会自动识别。少数需要专门驱动的硬件（如 NVIDIA 显卡、某些 Wi-Fi 芯片），可以通过包管理器安装，或者使用厂商提供的安装脚本。总的来说，Linux 的硬件支持比很多人想象的要好。

"为什么没有 C 盘？" 如前所述，Linux 不使用盘符。所有存储都挂载到目录树的某个位置。你的主目录 `/home/username` 就相当于 Windows 的 `C:\Users\Username`。外置驱动器通常挂载到 `/media` 或 `/mnt` 下。

"权限被拒绝是怎么回事？" Linux 的权限系统比 Windows 更严格。如果你试图修改系统文件或执行某些操作，可能需要管理员权限。使用 `sudo` 命令可以临时获得管理员权限，如 `sudo apt install package`。但不要养成什么都用 `sudo` 的习惯——权限限制是保护你的系统的。

"命令记不住怎么办？" 几乎每个命令都有手册页（man page），用 `man command` 查看。例如 `man ls` 显示 `ls` 命令的详细文档。更快捷的方式是 `command --help`，显示简要的帮助信息。还有 `tldr` 这样的工具提供更友好的速查手册。记住最常用的十几个命令就足够日常使用了，其他的可以随时查阅。

这些困惑都是暂时的。随着使用经验的积累，Linux 的工作方式会变得越来越自然。许多人在适应之后甚至会觉得 Linux 的方式更加合理和高效。重要的是保持耐心和好奇心，不要因为一时的不习惯就放弃。


=== Linux 发行版选择
// 找到适合你的发行版
// - 什么是发行版：内核 + 软件包 + 桌面环境 + 包管理器
// - 主流发行版家族：
//   Debian 系（Ubuntu、Linux Mint）
//   Red Hat 系（Fedora、CentOS）
//   Arch 系（Manjaro）
// - Ubuntu：为什么是 RoboMaster 的首选
//   对新手友好
//   ROS 官方支持
//   LTS 版本稳定
//   社区庞大、文档丰富
// - Ubuntu 版本选择：22.04 LTS vs 24.04 LTS
// - 桌面环境：GNOME、KDE、XFCE

=== 安装 Linux 的方式
// 根据需求选择安装方案
// - 双系统安装
//   优点：原生性能、完整体验
//   缺点：需要分区、切换不便
//   适合：长期深度使用
// - 虚拟机（VMware / VirtualBox）
//   优点：安全隔离、快照恢复、同时使用
//   缺点：性能损耗、资源占用
//   适合：学习入门、轻度使用
// - WSL / WSL2（Windows Subsystem for Linux）
//   优点：与 Windows 无缝集成、启动快
//   缺点：GUI 支持有限、USB 设备访问受限
//   适合：命令行开发、不需要硬件访问
// - 各方案的详细安装指南
// - 推荐配置与注意事项