#import "/template/template.typ": *
== 计算机视觉基础

== 传统视觉算法

== 深度学习和神经网络

== 相机模型

== 坐标变换

== 卡尔曼滤波
=== 什么是卡尔曼滤波？


=== 状态空间方程
状态空间方程是现代控制理论的基础，它以矩阵的形式表达系统的状态变量，输入及输出的关系。它可以描述和处理多输入多输出的系统。

=== 如何准确地测量体重
假设存在一个测量精度有限的体重秤。在实际测量过程中,该设备会产生随机误差,导致单次测量结果与真实体重之间存在偏差。为提高测量精度，可以通过多次采样与数据处理的方法获得更稳定的估计值。

首先，对同一对象进行 $n$ 次测量，每次记录体重秤的显示值。由于体重秤的误差通常呈随机分布，重复测量可以在一定程度上抵消单次测量的偏差。随后，将全部测量值求平均，得到较为稳定的估计值：

$ hat(x)_n = frac(1, n)(z_1 + z_2 + ... + z_n)= frac(1, n)sum_(i=1)^n z_i $

上述操作虽然在数学层面较为直观，但在工程应用中存在实现困难。根据平均值的定义，为了计算 $hat(x)_n$，需要存储所有历史测量值 $z_1, z_2, …, z_n$。当 $n$ 较大时，会产生显著的内存开销，对嵌入式设备而言尤为不利。此外，每次获得新的测量值后都需要重新遍历全部历史数据进行计算，其时间复杂度为 $O(n)$，会对处理器造成不必要的负担。

因此，需要寻找一种递推（Recursive）形式，使得算法满足以下特性：无需保存全部历史数据，无需重复计算，仅依赖上一次估计 $hat(x)_(n-1)$ 和当前测量 $z_n$

为实现上述目标，可将平均值公式改写为状态更新方程。通过代数变换，得到以下递推形式：

$
hat(x)_n = hat(x)_(n-1) + 1/n (z_n - hat(x)_(n-1))
$

该表达式揭示了递推估计的核心机制：第 $n$ 时刻的状态估计 $hat(x)_n$ 由两部分构成——前一时刻的估计值 $hat(x)_(n-1)$ 以及基于当前测量值 $z_n$ 的修正项 $(z_n - hat(x)_(n-1))$。因此,算法无需保存全部历史数据,仅需利用上一时刻的估计结果即可完成当前状态的更新,显著降低了计算复杂度（降至 $O(1)$）与存储需求。

#note("详细推导")[
$
hat(x)_n &= 1/n sum_(i=1)^n z_i 
= 1/n (sum_(i=1)^(n-1) z_i + z_n) \
&= 1/n sum_(i=1)^(n-1) z_i + 1/n z_n 
= (n-1)/(n(n-1)) sum_(i=1)^(n-1) z_i + 1/n z_n \
&= (n-1)/n dot 1/(n-1) sum_(i=1)^(n-1) z_i + 1/n z_n 
= (n-1)/n hat(x)_(n-1) + 1/n z_n \
&= hat(x)_(n-1) - 1/n hat(x)_(n-1) + 1/n z_n \
&= hat(x)_(n-1) + 1/n (z_n - hat(x)_(n-1))
$

#table(
  columns: (auto, 1fr),
  align: (center, left),
  stroke: (x, y) => (
    top: if y == 1 or y == 0 { 1pt } else { 0pt },
    bottom: if y == 5 { 1pt } else { 0pt },
  ),
  inset: 8pt,
  
  [*符号*], [*含义*],
  
  [$x$], 
  [体重的真值],
  
  [$z_n$], 
  [第 $n$ 次对体重的测量值],
  
  [$hat(x)_n$], 
  [基于前 $n$ 次测量值,对 $x$ 的估计值],
  
  [$hat(x)_(n-1)$], 
  [基于前 $n-1$ 次测量值,对 $x$ 的估计值],
  
  [$z_n - hat(x)_(n-1)$], 
  [测量残差：当前测量值与先验估计之间的偏差],
)
]

至此，上述平均值递推公式已经可以被视为一种特殊形式的状态估计滤波器。其中，增益系数

$
K_n = 1/n
$

决定了"当前观测"与"历史估计"在融合时各自的权重。该系数随测量次数增加而递减，表明随着可用数据增多，单次新测量对整体估计的影响逐渐减小。本例中，随着$n$的增加，$1/n$会下降。在一开始，因为没有足够的信息，第一次估计完全是基于第一次的测量值的$1/n|_(n=1)=1$. 随着迭代进行，每次后续测量的权重都在下降，并且会逐渐变得可以忽略不计。这一结构与卡尔曼滤波的状态更新公式在形式上完全一致：

$
hat(x)_k = hat(x)_(k|k-1) + K_k (z_k - h(hat(x)_(k|k-1)))
$

其中：
$hat(x)_(k|k-1)$ 为基于前 $k-1$ 次观测对第 $k$ 时刻的预测值（先验估计）$z_k$ 为第 $k$ 次测量值$h(dot)$ 为观测函数，将状态映射到观测空间$K_k$ 为卡尔曼增益，动态调节预测值与测量值的融合比例

在体重秤的简化场景中，系统状态不随时间变化（$hat(x)_(k|k-1) = hat(x)_(k-1)$），且观测函数为恒等映射（$h(x) = x$），因此递推平均公式可视为卡尔曼滤波在静态系统、确定性观测条件下的特例。


== 一维卡尔曼滤波器

=== 问题建模

==== 系统模型
- 状态方程（System Model / State Equation）
- 观测方程（Measurement Model / Observation Equation）
- 过程噪声与测量噪声

==== 符号体系说明
- 状态变量 $x_k$
- 观测值 $z_k$
- 先验估计 $hat(x)_(k|k-1)$ 与后验估计 $hat(x)_(k|k)$
- 误差协方差 $P_(k|k-1)$ 与 $P_(k|k)$

=== 卡尔曼滤波的五个方程

==== 预测步骤（Prediction / Time Update）
- 状态预测方程
- 协方差预测方程
- 物理意义解释

==== 更新步骤（Update / Measurement Update）
- 卡尔曼增益计算
- 状态更新方程
- 协方差更新方程
- 信息融合机制

=== 算法流程总结
- 初始化
- 预测-更新循环
- 流程图示

=== 实例：恒定速度目标跟踪

==== 问题描述
- 一维直线运动
- 位置测量含噪声
- 目标：估计位置与速度

==== 状态空间建模
- 状态向量 $bold(x) = vec(s, v)^T$（位置、速度）
- 状态转移矩阵
- 观测矩阵

==== 参数设置与仿真
- 过程噪声协方差 $Q$
- 测量噪声协方差 $R$
- 仿真结果分析

==== 滤波性能评估
- 估计误差分析
- 与简单平均的对比
- 参数敏感性分析

== 扩展卡尔曼滤波（EKF）

=== 非线性系统的挑战
- 线性卡尔曼滤波的局限性
- 非线性系统示例

=== 泰勒展开与线性化

==== 一阶泰勒近似
- 雅可比矩阵（Jacobian Matrix）
- 线性化的几何意义

==== 局部线性化策略
- 在估计点处展开
- 线性化误差分析

=== EKF 算法推导

==== 预测步骤
- 非线性状态预测
- 雅可比矩阵 $F_k$ 的计算
- 协方差预测

==== 更新步骤
- 观测雅可比矩阵 $H_k$
- 卡尔曼增益
- 状态与协方差更新

=== 实例：雷达目标跟踪

==== 问题描述
- 极坐标观测系统（距离、角度）
- 直角坐标状态空间
- 非线性观测方程

==== 观测模型线性化
- 雅可比矩阵推导
- 线性化点的选择

==== 仿真实验
- 场景设置
- EKF 性能分析
- 与线性假设的对比

=== EKF 的局限性与改进方向
- 高度非线性系统中的失效
- Unscented Kalman Filter (UKF) 简介
- Particle Filter 简介

== 多维卡尔曼滤波器

=== 从标量到向量

==== 多维状态空间
- 状态向量 $bold(x)_k in bb(R)^n$
- 观测向量 $bold(z)_k in bb(R)^m$
- 矩阵形式的系统方程

==== 协方差矩阵
- 误差协方差矩阵 $bold(P)_k$
- 多变量不确定性的表示
- 协方差传播

=== 多维卡尔曼滤波方程组

==== 预测步骤
$
bold(hat(x))_(k|k-1) &= bold(F)_k bold(hat(x))_(k-1|k-1) + bold(B)_k bold(u)_k \
bold(P)_(k|k-1) &= bold(F)_k bold(P)_(k-1|k-1) bold(F)_k^T + bold(Q)_k
$

==== 更新步骤
$
bold(K)_k &= bold(P)_(k|k-1) bold(H)_k^T (bold(H)_k bold(P)_(k|k-1) bold(H)_k^T + bold(R)_k)^(-1) \
bold(hat(x))_(k|k) &= bold(hat(x))_(k|k-1) + bold(K)_k (bold(z)_k - bold(H)_k bold(hat(x))_(k|k-1)) \
bold(P)_(k|k) &= (bold(I) - bold(K)_k bold(H)_k) bold(P)_(k|k-1)
$

==== 符号说明
#table(
  columns: (auto, 1fr),
  align: (center, left),
  stroke: (x, y) => (
    top: if y == 0 { 1pt } else { 0pt },
    bottom: if y == 0 or y == 9 { 1pt } else { 0pt },
  ),
  inset: 8pt,
  
  [*符号*], [*含义*],
  
  [$bold(x)_k in bb(R)^n$], 
  [第 $k$ 时刻的系统状态向量（$n$ 维）],
  
  [$bold(z)_k in bb(R)^m$], 
  [第 $k$ 时刻的观测向量（$m$ 维）],
  
  [$bold(F)_k in bb(R)^(n times n)$], 
  [状态转移矩阵：描述系统动态特性],
  
  [$bold(H)_k in bb(R)^(m times n)$], 
  [观测矩阵：将状态空间映射到观测空间],
  
  [$bold(B)_k in bb(R)^(n times l)$], 
  [控制输入矩阵],
  
  [$bold(u)_k in bb(R)^l$], 
  [控制输入向量],
  
  [$bold(Q)_k in bb(R)^(n times n)$], 
  [过程噪声协方差矩阵],
  
  [$bold(R)_k in bb(R)^(m times m)$], 
  [测量噪声协方差矩阵],
  
  [$bold(P)_(k|k) in bb(R)^(n times n)$], 
  [后验误差协方差矩阵],
)

=== 实例：二维平面目标跟踪

==== 问题描述
- 二维平面运动（$x$-$y$ 坐标系）
- 状态：位置 + 速度（4 维状态向量）
- 观测：带噪声的位置测量

==== 状态空间模型

===== 状态向量定义
$
bold(x)_k = vec(x_k, dot(x)_k, y_k, dot(y)_k)
$

===== 状态转移矩阵（匀速运动模型）
$
bold(F) = mat(
  1, Delta t, 0, 0;
  0, 1, 0, 0;
  0, 0, 1, Delta t;
  0, 0, 0, 1
)
$

===== 观测矩阵
$
bold(H) = mat(
  1, 0, 0, 0;
  0, 0, 1, 0
)
$

==== 噪声协方差设置

===== 过程噪声建模
- 加速度不确定性
- 离散化白噪声加速度模型
- $bold(Q)$ 矩阵构造

===== 测量噪声建模
- 传感器精度
- $bold(R)$ 矩阵设置

==== 仿真实验

===== 场景设置
- 目标运动轨迹
- 采样频率
- 噪声水平

===== 滤波结果
- 位置估计精度
- 速度估计精度
- 轨迹可视化

===== 性能分析
- 均方根误差（RMSE）
- 估计不确定性椭圆
- 收敛性分析