#import "/template/template.typ": *
== 计算机视觉基础

== 传统视觉算法

== 深度学习和神经网络

== 相机模型

== 坐标变换

== 卡尔曼滤波
=== 什么是卡尔曼滤波？


=== 状态空间方程
状态空间方程是现代控制理论的基础，它以矩阵的形式表达系统的状态变量，输入及输出的关系。它可以描述和处理多输入多输出的系统。

=== 如何准确的测量体重
假设存在一个测量精度有限的体重秤。在实际测量过程中,该设备会产生随机误差,导致单次测量结果与真实体重之间存在偏差。为提高测量精度，可以通过多次采样与数据处理的方法获得更稳定的估计值。

首先，对同一对象进行多次测量 $n$ 次，每次记录体重秤的显示值。由于体重秤的误差通常呈随机分布，重复测量可以在一定程度上抵消单次测量的偏差。随后，将全部测量值求平均，得到较为稳定的估计值：

$ hat(x)_n = frac(1, n)(z_1 + z_2 + ... + z_n)= frac(1, n)sum_(i=1)^n z_i $

以上操作虽然在数学层面是非常直观的，但是它在工程应用层面需要进一步优化。这是因为根据平均值的定义，为了估计$hat(x)_n$，我们需要存储下所有的历史测量值，这对内存开销巨大。并且每次获得了新的测量值后都需要完全重新从第一次测量开始计算，这对CPU算力也消耗巨大。因此我们可以考虑，是否可以通过储存上一时刻的估计值$hat(x)_(n-1)$并在新的测量完成后更新它。


$
overline(x)_(n|n) &= 1/n sum_(i=1)^n (z_i) 
= 1/n (sum_(i=1)^(n-1) (z_i) + z_n) \
&= 1/n sum_(i=1)^(n-1) (z_i) + 1/n z_n 
= (n-1)/(n(n-1)) sum_(i=1)^(n-1) (z_i) + 1/n z_n \
&= (n-1)/n dot 1/(n-1) sum_(i=1)^(n-1) (z_i) + 1/n z_n 
= (n-1)/n overline(x)_(n-1|n-1) + 1/n z_n \
&= overline(x)_(n-1|n-1) - 1/n overline(x)_(n-1|n-1) + 1/n z_n \
&= overline(x)_(n-1|n-1) + 1/n (z_n - overline(x)_(n-1|n-1))
$
#table(
  columns: (auto, 1fr),
  align: (center, left),
  stroke: (x, y) => (
    top: if y == 0 or y == 1 { 1pt } else { 0pt },
    bottom: if y == 8 { 1pt } else { 0pt },
  ),
  inset: 8pt,
  
  [*符号*], [*含义*],
  
  [$overline(x)_(n|n)$], 
  [基于前 $n$ 次测量,对第 $n$ 时刻状态的后验估计(滤波估计值)],
  
  [$overline(x)_(n-1|n-1)$], 
  [基于前 $n-1$ 次测量,对第 $n-1$ 时刻状态的后验估计],
  
  [$z_n$], 
  [第 $n$ 次测量值(观测值)],
  
  [$z_i$], 
  [第 $i$ 次测量值, $i = 1, 2, ..., n$],
  
  [$n$], 
  [当前时刻或测量次数],
  
  [$n-1$], 
  [上一时刻或前一次测量],
  
  [$overline(x)_(k|k)$], 
  [一般形式:基于 $1$ 到 $k$ 的所有测量,对 $k$ 时刻状态的最优估计],
  
  [$overline(x)_(k|k-1)$], 
  [一般形式:基于 $1$ 到 $k-1$ 的测量,对 $k$ 时刻状态的先验估计(预测值)],
)