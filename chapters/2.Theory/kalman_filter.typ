#import "/template/template.typ": *
#definition()[
#set list(indent: 2em)
#{
  set par(first-line-indent: 0pt)
  [本章使用的符号规定：]
}

- *粗体小写字母* 表示向量，例如 $bold(x)$
- *粗体大写字母* 表示矩阵，例如 $bold(A)$
- *普通小写字母* 标量或向量的分量
- *普通大写字母* 表示矩阵元素
]
=== 什么是卡尔曼滤波？



=== 如何准确地测量体重
假设存在一个测量精度有限的体重秤。在实际测量过程中,该设备会产生随机误差,导致单次测量结果与真实体重之间存在偏差。为提高测量精度，可以通过多次采样与数据处理的方法获得更稳定的估计值。

首先，对同一对象进行 $n$ 次测量，每次记录体重秤的显示值。由于体重秤的误差通常呈随机分布，重复测量可以在一定程度上抵消单次测量的偏差。随后，将全部测量值求平均，得到较为稳定的估计值：

$ hat(x)_n = frac(1, n)(z_1 + z_2 + ... + z_n)= frac(1, n)sum_(i=1)^n z_i $

上述操作虽然在数学层面较为直观，但在工程应用中存在实现困难。根据平均值的定义，为了计算 $hat(x)_n$，需要存储所有历史测量值 $z_1, z_2, …, z_n$。当 $n$ 较大时，会产生显著的内存开销，对嵌入式设备而言尤为不利。此外，每次获得新的测量值后都需要重新遍历全部历史数据进行计算，其时间复杂度为 $O(n)$，会对处理器造成不必要的负担。

因此，需要寻找一种递推（Recursive）形式，使得算法满足以下特性：无需保存全部历史数据，无需重复计算，仅依赖上一次估计 $hat(x)_(n-1)$ 和当前测量 $z_n$

为实现上述目标，可将平均值公式改写为状态更新方程。通过代数变换，得到以下递推形式：

$
hat(x)_n = hat(x)_(n-1) + 1/n (z_n - hat(x)_(n-1))
$

该表达式揭示了递推估计的核心机制：第 $n$ 时刻的状态估计 $hat(x)_n$ 由两部分构成——前一时刻的估计值 $hat(x)_(n-1)$ 以及基于当前测量值 $z_n$ 的修正项 $(z_n - hat(x)_(n-1))$。因此,算法无需保存全部历史数据,仅需利用上一时刻的估计结果即可完成当前状态的更新,显著降低了计算复杂度（降至 $O(1)$）与存储需求。

#note("详细推导")[
$
hat(x)_n &= 1/n sum_(i=1)^n z_i 
= 1/n (sum_(i=1)^(n-1) z_i + z_n) \
&= 1/n sum_(i=1)^(n-1) z_i + 1/n z_n 
= (n-1)/(n(n-1)) sum_(i=1)^(n-1) z_i + 1/n z_n \
&= (n-1)/n dot 1/(n-1) sum_(i=1)^(n-1) z_i + 1/n z_n 
= (n-1)/n hat(x)_(n-1) + 1/n z_n \
&= hat(x)_(n-1) - 1/n hat(x)_(n-1) + 1/n z_n \
&= hat(x)_(n-1) + 1/n (z_n - hat(x)_(n-1))
$

#table(
  columns: (auto, 1fr),
  align: (center, left),
  stroke: (x, y) => (
    top: if y == 1 or y == 0 { 1pt } else { 0pt },
    bottom: if y == 5 { 1pt } else { 0pt },
  ),
  inset: 8pt,
  
  [*符号*], [*含义*],
  
  [$x$], 
  [体重的真值],
  
  [$z_n$], 
  [第 $n$ 次对体重的测量值],
  
  [$hat(x)_n$], 
  [基于前 $n$ 次测量值,对 $x$ 的估计值],
  
  [$hat(x)_(n-1)$], 
  [基于前 $n-1$ 次测量值,对 $x$ 的估计值],
  
  [$z_n - hat(x)_(n-1)$], 
  [测量残差：当前测量值与先验估计之间的偏差],
)
]

至此，上述平均值递推公式已经可以被视为一种特殊形式的状态估计滤波器。其中，增益系数

$
K_n = 1/n
$

决定了"当前观测"与"历史估计"在融合时各自的权重。该系数随测量次数增加而递减，表明随着可用数据增多，单次新测量对整体估计的影响逐渐减小。本例中，随着$n$的增加，$1/n$会下降。在一开始，因为没有足够的信息，第一次估计完全是基于第一次的测量值的$1/n|_(n=1)=1$. 随着迭代进行，每次后续测量的权重都在下降，并且会逐渐变得可以忽略不计。这一结构与卡尔曼滤波的状态更新公式在形式上完全一致：

$
hat(x)_k = hat(x)_(k|k-1) + K_k (z_k - h(hat(x)_(k|k-1)))
$

其中：
$hat(x)_(k|k-1)$ 为基于前 $k-1$ 次观测对第 $k$ 时刻的预测值（先验估计）$z_k$ 为第 $k$ 次测量值$h(dot)$ 为观测函数，将状态映射到观测空间$K_k$ 为卡尔曼增益，动态调节预测值与测量值的融合比例

在体重秤的简化场景中，系统状态不随时间变化（$hat(x)_(k|k-1) = hat(x)_(k-1)$），且观测函数为恒等映射（$h(x) = x$），因此递推平均公式可视为卡尔曼滤波在静态系统、确定性观测条件下的特例。


将上述公式重新标注为：

$
hat(x)_n = underbrace(hat(x)_(n-1), "先验估计") + underbrace(1/n, "增益系数") underbrace((z_n - hat(x)_(n-1)), "测量残差")
$

这一形式揭示了三个关键组成部分：

*先验估计（Prior Estimate）*

$hat(x)_(n-1)$ 代表在获得第 $n$ 次测量之前，系统对状态的当前认知。对于静态系统（状态不随时间变化），先验估计即为上一时刻的后验估计。该项体现了系统对历史信息的继承。

*测量残差（Measurement Residual）*

$r_n = z_n - hat(x)_(n-1)$ 反映了观测值与先验估计之间的偏差。若测量值高于估计值，则 $r_n > 0$；反之则 $r_n < 0$。测量残差是滤波器进行状态修正的驱动信号。

*增益系数（Gain Coefficient）*

$K_n = 1/n$ 决定了测量残差在状态更新中所占的权重，是滤波器设计中的核心参数。

上述"先验估计 + 增益 × 残差"的结构，正是所有递推估计算法的通用框架。

=== 从体重秤到赛车：静态估计的局限性
在第 1 章中，我们成功地用递推平均估计了体重：

$
hat(x)_n = hat(x)_(n-1) + 1/n (z_n - hat(x)_(n-1))
$

之所以该方法能够有效，是因为体重这一物理量在测量过程中近似静止不变，因此所有测量偏差都可以视为传感器噪声，重复测量并求平均即可逐渐逼近真实值。

然而，当我们将同样的方法应用于一个动态系统时，情况就会发生改变。现在考虑一个新场景：追踪赛道上的赛车。

*假设：*这个赛车起始位置位于 0 米，并以 20 米/秒的恒定速度行驶。GPS 每秒测量一次位置，但有 ±5 米的随机误差

因此，按照按照物理规律，赛车的真实轨迹为：
$p_t=20 dot t$ 其中$t$为秒数

但 GPS 的测量值满足：
$z_t=p_t+"噪声"$

#figure(
table(
columns: (auto, auto, auto, auto, auto),
align: (center, center, center, center, center),
[*时刻*\ (秒)], 
[*真实位置*\ (米)], 
[*GPS 测量*\ (米)], 
[*递推平均*\ (米)], 
[*估计误差*\ (米)],

[0], [0], [1.2], [1.2], [+1.2],
[1], [20], [18.3], [9.8], [−10.2],
[2], [40], [43.1], [20.9], [−19.1],
[3], [60], [56.8], [29.9], [−30.1],
[4], [80], [82.4], [40.4], [−39.6],
[5], [100], [97.6], [49.9], [−50.1],
),
caption: [递推平均追踪赛车的实验数据]
)

如表所示，估计值严重落后，且差距不断扩大。究其原因，递推平均的公式结构：

$
hat(x)_n = underbrace(hat(x)_(n-1), "上次估计") + underbrace(frac(1, n) (z_n - hat(x)_(n-1)), "基于测量的修正")
$

其本质问题在于：该公式*只有修正，没有预测*。随着测量次数 $n$ 增加，增益系数 $1/n$ 不断减小，新测量对估计值的影响逐渐微弱。该公式假设被估计的量保持不变，因此所有测量偏差都被视为需要消除的噪声。但对于运动的赛车，测量值的变化不仅包含噪声，更反映了*真实的位置变化*。递推平均无法区分这两者，只是机械地对所有历史数据求平均，导致估计值始终"追不上"真实位置。

正确的思路应该是：在获得新测量之前，先根据赛车的运动规律*主动预测*它现在应该在哪里，然后再用测量值进行修正。这就是 g-h 滤波器的核心思想。

==== g-h 滤波器

对于运动物体，估计公式应该包含*预测*步骤：

#align(center)[
  #block(
    fill: rgb("#e3f2fd"),
    inset: 15pt,
    radius: 6pt,
    stroke: 1.5pt + rgb("#2196f3")
  )[
    估计 = #text(fill: blue)[*预测*]（基于运动模型）+ 修正（基于测量）
  ]
]

假设车辆是匀速运动的，在第 $k-1$ 时刻已经得到了位置与速度的估计值：
#set list(indent: 4em)
- 位置：$hat(p)_(k-1)$
- 速度：$hat(v)_(k-1)$

根据匀速运动模型，可以预测第 $k$ 时刻的位置：

$ p_("pred",k) = hat(p)_(k-1) + hat(v)_(k-1) dot Delta t $

其中 $Delta t$ 为时间间隔（本例为 1 秒）。

速度在匀速假设下保持不变：

$ v_("pred",k) = hat(v)_(k-1) $

这是最基本的直线匀速运动模型。

*示例：*
若 $hat(p)_0 = 0$ 米，$hat(v)_0 = 15$ 米/秒，则

$ p_("pred",1) = 0 + 15 * 1 = 15 "米" $

接着，我们要对之前的预测值进行*修正*：

当 GPS 测量值 $z_k$ 到来时，可以计算预测与测量之间的残差（Residual）：

$ r_k = z_k - p_("pred",k) $

示例：若 $z_1 = 18.3$ 米，

$ r_1 = 18.3 - 15 = 3.3 "米" $


*位置修正*

预测与测量的加权融合如下：

$ hat(p)_k = p_("pred",k) + g * r_k $

其中 $g$ 为位置增益，满足 $0 < g < 1$。

那么，如果设置$g = 0$，则说明完全信任预测；若$g = 1$，则完全信任测量；$g = 0.3$则可以认为，预测 70%，测量 30%

*示例（$g = 0.3$）：*

$ hat(p)_1 = 15 + 0.3 * 3.3 = 15.99 "米" $


*速度修正（g-h 滤波器的核心）*

位置残差反映运动趋势误差，因此也用于修正速度：

$ hat(v)_k = v_("pred",k) + (h / (Delta t)) * r_k $

其中 $h$ 为速度增益，$0 < h < 1$。

#note("为什么要除以 $Delta t$？")[
残差 $r_k$ 的单位是米，为了将“位置误差”转成“速度误差”，需要除以时间间隔：

$("米") / ("秒") = "米/秒"$

含义：  
“若位置误差为 $r_k$ 米，那速度应增加多少才能在 $Delta t$ 秒内弥补这一误差？”
]

示例（$h = 0.1$, $Delta t = 1$ 秒）：

$ hat(v)_1 = 15 + 0.1 * 3.3 = 15.33 "米/秒" $

#block(
  fill: rgb("#e8f5e9"),
  inset: 10pt,
  radius: 4pt,
)[
  *观察：*

  - 残差为正 → 预测位置偏低  
  - 速度被上调（15 → 15.33 米/秒）  
  - 若赛车走得比预期远，则它速度更快
]


*g-h 滤波器完整算法*

#block(
  fill: rgb("#f3e5f5"),
  inset: 12pt,
  radius: 4pt,
  stroke: 1.5pt + rgb("#9c27b0")
)[
  *g-h 滤波器算法*

  *输入：*
  - 上一时刻估计：$hat(p)_(k-1)$, $hat(v)_(k-1)$
  - 当前测量：$z_k$
  - 时间间隔：$Delta t$
  - 增益参数：$g, h$

  *步骤 1：预测*
  $ p_("pred",k) = hat(p)_(k-1) + hat(v)_(k-1) * Delta t $
  $ v_("pred",k) = hat(v)_(k-1) $

  *步骤 2：计算残差*
  $ r_k = z_k - p_("pred",k) $

  *步骤 3：修正*
  $ hat(p)_k = p_("pred",k) + g * r_k $
  $ hat(v)_k = v_("pred",k) + (h / Delta t) * r_k $

  *输出：*
  $hat(p)_k$, $hat(v)_k$
]


*数值示例：追踪赛车*

参数设定：
- 真实速度：$20 "米/秒"$
- $Delta t = 1$ 秒
- $g = 0.3$, $h = 0.1$
- 初始估计：$hat(p)_0=0$, $hat(v)_0=15$（故意错误）

第 1 次迭代

测量：$z_1 = 18.3$ 米

预测：
$ p_("pred"1) = 0 + 15 = 15 "米" $
$ v_("pred",1) = 15 $

残差：
$r_1 = 3.3 "米"$

修正：
$ hat(p)_1 = 15 + 0.3 * 3.3 = 15.99 $
$ hat(v)_1 = 15 + 0.1 * 3.3 = 15.33 $

第 2 次迭代

测量：$z_2 = 43.1$ 米

预测：
$ p_("pred",2) = 15.99 + 15.33 = 31.32 $
$ v_("pred",2) = 15.33 $

残差：
$r_2 = 11.78$

修正：
$ hat(p)_2 = 31.32 + 0.3 * 11.78 = 34.85 $
$ hat(v)_2 = 15.33 + 0.1 * 11.78 = 16.51 $


*完整追踪过程表格*

#figure(
table(
  columns: (auto, auto, auto, auto, auto, auto),
  align: center,
  
  [*时刻* (秒)], 
  [*真实位置* (米)], 
  [*GPS 测量* (米)], 
  [*g-h 估计* (米)], 
  [*真实速度*], 
  [*速度估计*],
  
  [0], [0], [—], [0.0], [20], [15.00],
  [1], [20], [18.3], [16.0], [20], [15.33],
  [2], [40], [43.1], [34.9], [20], [16.51],
  [3], [60], [56.8], [54.3], [20], [17.68],
  [4], [80], [82.4], [74.8], [20], [18.73],
  [5], [100], [97.6], [96.0], [20], [19.60],
),
caption: [g-h 滤波器追踪赛车实验数据]
)

#block(
  fill: rgb("#e8f5e9"),
  inset: 10pt,
  radius: 4pt,
)[
  *关键观察：*
  
  - 位置误差逐步收敛  
  - 速度估计自动逼近真实值  
  - 初始误差可被消除  
  - 完全不同于递推平均的「滞后问题」
]


*对比：递推平均 vs g-h 滤波器*

#figure(
table(
  columns: (auto, auto, auto, auto),
  align: center,
  
  [*时刻 (秒)*], [*真实位置 (米)*], [*递推平均 (米)*], [*g-h 滤波 (米)*],
  
  [0], [0], [1.2], [0.0],
  [1], [20], [9.8], [16.0],
  [2], [40], [20.9], [34.9],
  [3], [60], [29.9], [54.3],
  [4], [80], [40.4], [74.8],
  [5], [100], [49.9], [96.0],
),
caption: [两种方法在同一数据上的对比]
)

#table(
  columns: (auto, 1fr, 1fr),
  align: (center, left, left),
  
  [], [*递推平均*], [*g-h 滤波器*],
  
  [适用场景], [静态量], [动态系统],
  [预测机制], [✗ 无], [✓ 有（运动模型）],
  [状态数量], [1], [2（位置+速度）],
  [增益系数], [$1/n$（递减）], [$g,h$（固定）],
  [第5秒误差], [50.1 米], [4.0 米],
  [追踪能力], [严重滞后], [成功追踪],
)



==== 从标量到矩阵：为高维系统做准备

前面通过标量公式完整描述了 g-h 滤波器的工作原理。但在实际应用中，往往需要处理更复杂的系统：

*考虑以下场景的状态数量：*
- *一维运动*：$(p, v)$ — 2个状态
- *二维平面运动*：$(x, y, v_x, v_y)$ — 4个状态  
- *三维空间运动*：$(x, y, z, v_x, v_y, v_z)$ — 6个状态
- *加入加速度*：$(x, y, z, v_x, v_y, v_z, a_x, a_y, a_z)$ — 9个状态

如果继续用标量公式，二维系统就需要写4个方程，三维系统需要6个方程。更糟糕的是，这些方程的*结构完全相同*，只是作用在不同的变量上。

矩阵形式提供了统一的框架：*无论系统有多少个状态，公式形式都保持不变*。

*第一步：将标量组织成向量*

回顾我们的两个修正公式：

$ hat(p)_k &= p_(p r e d) + g dot (z_k - p_(p r e d)) \
  hat(v)_k &= v_(p r e d) + h / (Delta t) dot (z_k - p_(p r e d)) $

观察它们的共同结构：
#align(center)[
  估计 = 预测 + 增益 × 残差
]

两个公式的唯一区别是*增益系数不同*（$g$ vs $h/Delta t$）。既然结构相同，可以将它们"打包"成向量形式：

$ vec(hat(p)_k, hat(v)_k) = vec(p_(p r e d), v_(p r e d)) + vec(g, h / (Delta t)) dot (z_k - p_(p r e d)) $

定义：

- *状态向量*：$bold(x)_k = mat(p_k, v_k)$

- *增益向量*：$bold(K) = mat(g, h / (Delta t))$

则上式可以简写为：

$ hat(bold(x))_k = bold(x)_(p r e d) + bold(K) dot (z_k - p_(p r e d)) $

#block(
  fill: rgb("#e8f4f8"),
  inset: 10pt,
  radius: 4pt,
  width: 100%,
)[
  *关键观察*：增益向量 $bold(K)$ 的每一行对应一个状态的修正规则。
  - 第一行 $g$：控制位置如何修正
  - 第二行 $h/Delta t$：控制速度如何修正
]

*第二步：处理"测量只有部分状态"的情况*

现在遇到一个问题：残差计算中的 $p_(p r e d)$ 如何从状态向量 $bold(x)_(p r e d) = vec(p_(p r e d), v_(p r e d))$ 中提取？

问题的本质是：*GPS 只能测量位置，无法测量速度*。用数学语言说：
- 状态空间维度：2（位置 + 速度）
- 测量空间维度：1（仅位置）

需要一个映射，将状态空间投影到测量空间。这就是*观测矩阵（Observation Matrix）* $bold(H)$ 的作用。

对于"只测量位置"的情况：

$ bold(H) = mat(1, 0) $

它的作用是：

$ bold(H) bold(x)_(p r e d) = mat(1, 0) vec(p_(p r e d), v_(p r e d)) = 1 dot p_(p r e d) + 0 dot v_(p r e d) = p_(p r e d) $

*直观理解*：$bold(H)$ 就像一个"提取器"，从完整状态中提取出可测量的部分。

#block(
  fill: rgb("#f0f8ff"),
  inset: 10pt,
  radius: 4pt,
  width: 100%,
)[
  #{
  set par(first-line-indent: 0pt)
  [*为什么需要 $bold(H)$？*]
}
  
  
  对于更复杂的系统，观测矩阵变得必不可少：
  - *雷达测距*：只测量距离，不测量速度 → $bold(H) = mat(1, 0)$
  - *加速度计*：只测量加速度，不测量位置和速度 → $bold(H) = mat(0, 0, 1)$
  - *GPS+速度计*：同时测量位置和速度 → $bold(H) = mat(1, 0; 0, 1)$
]

*第三步：完整的矩阵形式*

有了状态向量 $bold(x)$、增益向量 $bold(K)$ 和观测矩阵 $bold(H)$，可以将 g-h 滤波器写成完全统一的形式：

#align(center)[
  #block(
    fill: rgb("#fff4e6"),
    inset: 12pt,
    radius: 4pt,
    stroke: 1.5pt + rgb("#ff9800")
  )[
    $ hat(bold(x))_k = bold(x)_(p r e d) + bold(K) (z_k - bold(H) bold(x)_(p r e d)) $
  ]
]

*公式各部分的物理意义*：

#table(
  columns: (auto, 1fr),
  align: (center, left),
  inset: (8pt), 
  stroke:none,
  
  // --- 表格内容 ---
  
  [$bold(x)_(p r e d)$],
  [模型预测的状态。],

  [$bold(H) bold(x)_(p r e d)$],
  [预测状态对应的测量值（"如果状态是 $bold(x)_(p r e d)$，传感器应该读到什么"）。],

  [$z_k - bold(H) bold(x)_(p r e d)$],
  [测量残差（实际测量 $z_k$ vs 预期测量 $bold(H) bold(x)_(p r e d)$）。],

  [$bold(K)$],
  [决定多大程度上信任测量残差（即多大程度上校正预测值）。],

  [$hat(bold(x))_k$],
  [融合预测与测量后的最优状态估计。],
)


*验证：展开矩阵公式*

为确保矩阵形式确实等价于标量公式，展开验证：

$ vec(hat(p)_k, hat(v)_k) &= vec(p_(p r e d), v_(p r e d)) + vec(g, h / (Delta t)) (z_k - mat(1, 0) vec(p_(p r e d), v_(p r e d))) \
&= vec(p_(p r e d), v_(p r e d)) + vec(g, h / (Delta t)) (z_k - p_(p r e d)) \
&= vec(p_(p r e d) + g(z_k - p_(p r e d)), v_(p r e d) + h / (Delta t)(z_k - p_(p r e d))) $

结果与标量公式完全一致！


*预测步骤的矩阵形式*

为了完整性，预测步骤也可以用矩阵表示。回顾上一章定义的状态转移矩阵：

$ bold(F) = mat(1, Delta t; 0, 1) $

预测步骤写为：

$ bold(x)_(p r e d) = bold(F) hat(bold(x))_(k-1) $

展开验证：

$ vec(p_(p r e d), v_(p r e d)) = mat(1, Delta t; 0, 1) vec(hat(p)_(k-1), hat(v)_(k-1)) = vec(hat(p)_(k-1) + Delta t dot hat(v)_(k-1), hat(v)_(k-1)) $

正是我们的位置和速度预测公式！

==== 完整算法流程（矩阵形式）

#block(
  fill: rgb("#fff8e1"),
  inset: 12pt,
  radius: 4pt,
  stroke: 1pt + rgb("#ffa726")
)[
  *g-h 滤波器算法（矩阵形式）*
  
  *定义*：
  
  $ bold(x)_k = vec(p_k, v_k), quad bold(F) = mat(1, Delta t; 0, 1), quad bold(H) = mat(1, 0), quad bold(K) = vec(g, h / (Delta t)) $
  
  *输入*：上一时刻估计 $hat(bold(x))_(k-1)$，当前测量 $z_k$
  
  *步骤 1：预测*
  $ bold(x)_(p r e d) = bold(F) hat(bold(x))_(k-1) $

  *步骤 2：修正*
  $ hat(bold(x))_k = bold(x)_(p r e d) + bold(K) (z_k - bold(H) bold(x)_(p r e d)) $
  
  *输出*：当前时刻最优估计 $hat(bold(x))_k$
]


==== g-h 滤波器的局限性

g-h 滤波器已经具备了现代滤波器的基本结构：
$ "估计" = "预测" + "增益" times "残差" $

它唯一缺少的，是*自动计算最优增益*的机制。卡尔曼滤波正是通过以下两点解决了这个问题：
1. 通过*误差协方差矩阵 $bold(P)_k$* 量化估计的不确定性
2. 通过*最小化估计误差*的准则，动态推导出最优增益 $bold(K)_k$

下一章将揭开这一机制的数学原理，展示卡尔曼滤波如何将 g-h 滤波器的直观思想发展为完整的最优估计理论。
