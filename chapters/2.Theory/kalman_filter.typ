#import "/template/template.typ": *

// ==================== 修改说明 ====================
// 本文档标注了所有修改位置，格式为：
// 【修改 N】原因：xxx
// 修改内容在对应位置直接替换
// ================================================

#definition()[
#set list(indent: 2em)
#{
  set par(first-line-indent: 0pt)
  [本章使用的符号规定：]
}

- *粗体小写字母* 表示向量，例如 $bold(x)$
- *粗体大写字母* 表示矩阵，例如 $bold(A)$
- *普通小写字母* 标量或向量的分量
- *普通大写字母* 表示矩阵元素
]

=== 什么是卡尔曼滤波？

// 【修改 1】此处原文为空，建议补充简要定义或删除该标题

=== 如何准确地测量体重

// 【修改 2】原因：原文三句话表达同一个意思，存在冗余
// 原文："假设存在一个测量精度有限的体重秤。在实际测量过程中,该设备会产生随机误差,导致单次测量结果与真实体重之间存在偏差。为提高测量精度，可以通过多次采样与数据处理的方法获得更稳定的估计值。"
// 修改后：
考虑一个存在随机测量误差的体重秤。单次测量无法得到准确结果，但通过多次测量取平均，可以获得更稳定的估计值。

// 【修改 3】原因：原文"首先，对同一对象进行..."过于繁琐
// 原文删除，直接给出公式：
对同一对象进行 $n$ 次测量，取平均值作为估计：

$ hat(x)_n = frac(1, n) sum_(i=1)^n z_i $

// 【修改 4】原因：原文冗余严重，多次重复"内存开销"、"不利"等表达
// 原文："上述操作虽然在数学层面较为直观，但在工程应用中存在实现困难。根据平均值的定义，为了计算...会对处理器造成不必要的负担。"
// 修改后：
然而，直接计算平均值需要存储全部历史数据 $z_1, z_2, ..., z_n$，且每次更新都需遍历所有数据，时间复杂度为 $O(n)$。对于资源受限的嵌入式系统，这一方法难以实现。

// 【修改 5】原因："因此，需要寻找一种...使得算法满足以下特性"是典型AI句式
// 原文："因此，需要寻找一种递推（Recursive）形式，使得算法满足以下特性：无需保存全部历史数据，无需重复计算，仅依赖上一次估计..."
// 修改后：
更理想的方案是递推（Recursive）形式：仅利用上一次估计 $hat(x)_(n-1)$ 与当前测量 $z_n$ 完成更新，无需保存历史数据。

// 【修改 6】原因："为实现上述目标"是冗余过渡
// 原文："为实现上述目标，可将平均值公式改写为状态更新方程。通过代数变换，得到以下递推形式："
// 修改后：
通过代数变换，平均值公式可改写为：

$
hat(x)_n = hat(x)_(n-1) + 1/n (z_n - hat(x)_(n-1))
$

// 【修改 7】原因："该表达式揭示了递推估计的核心机制"是空洞评价，后续解释也过于冗长
// 原文："该表达式揭示了递推估计的核心机制：第 $n$ 时刻的状态估计...显著降低了计算复杂度（降至 $O(1)$）与存储需求。"
// 修改后：
上式表明，第 $n$ 次估计仅依赖 $hat(x)_(n-1)$ 与 $z_n$，时间和空间复杂度均为 $O(1)$。

#note("详细推导")[
$
hat(x)_n &= 1/n sum_(i=1)^n z_i 
= 1/n (sum_(i=1)^(n-1) z_i + z_n) \
&= 1/n sum_(i=1)^(n-1) z_i + 1/n z_n 
= (n-1)/(n(n-1)) sum_(i=1)^(n-1) z_i + 1/n z_n \
&= (n-1)/n dot 1/(n-1) sum_(i=1)^(n-1) z_i + 1/n z_n 
= (n-1)/n hat(x)_(n-1) + 1/n z_n \
&= hat(x)_(n-1) - 1/n hat(x)_(n-1) + 1/n z_n \
&= hat(x)_(n-1) + 1/n (z_n - hat(x)_(n-1))
$

#table(
  columns: (auto, 1fr),
  align: (center, left),
  stroke: (x, y) => (
    top: if y == 1 or y == 0 { 1pt } else { 0pt },
    bottom: if y == 5 { 1pt } else { 0pt },
  ),
  inset: 8pt,
  
  [*符号*], [*含义*],
  [$x$], [体重真值],
  [$z_n$], [第 $n$ 次测量值],
  [$hat(x)_n$], [基于前 $n$ 次测量的估计值],
  [$hat(x)_(n-1)$], [基于前 $n-1$ 次测量的估计值],
  [$z_n - hat(x)_(n-1)$], [测量残差],
)
]

// 【修改 8】原因：此段过于冗长，且"递推估计的核心机制"已在前文出现
// 原文："至此，上述平均值递推公式已经可以被视为一种特殊形式的状态估计滤波器。其中，增益系数...本例中，随着$n$的增加..."
// 修改后（精简）：
上述递推公式已具备状态估计滤波器的基本形式。其中增益系数 $K_n = 1/n$ 决定了测量值与历史估计的融合权重。随着 $n$ 增加，$K_n$ 递减——可用数据越多，单次新测量的影响越小。

// 【修改 9】原因："这一结构与卡尔曼滤波的状态更新公式在形式上完全一致"可以更简洁
// 原文后半部分修改：
这一结构与卡尔曼滤波的状态更新公式形式一致：

$
hat(x)_k = hat(x)_(k|k-1) + K_k (z_k - h(hat(x)_(k|k-1)))
$

// 【修改 10】原因：符号解释用列表更清晰，原文连续写在一起不易阅读
其中：
- $hat(x)_(k|k-1)$：基于前 $k-1$ 次观测的先验估计
- $z_k$：第 $k$ 次测量值
- $h(dot)$：观测函数
- $K_k$：卡尔曼增益

在体重秤场景中，状态不随时间变化（$hat(x)_(k|k-1) = hat(x)_(k-1)$），观测函数为恒等映射（$h(x) = x$），因此递推平均可视为卡尔曼滤波在静态系统下的特例。

// 【修改 11】原因：underbrace公式下方的解释与正文重复
// 保留公式，删除后续冗余段落
将递推公式标注为：

$
hat(x)_n = underbrace(hat(x)_(n-1), "先验估计") + underbrace(1/n, "增益") underbrace((z_n - hat(x)_(n-1)), "残差")
$

// 【修改 12】原因：三个概念的解释过于冗长，压缩为简洁定义
// 原文中"先验估计"、"测量残差"、"增益系数"各用一段解释
// 修改后合并为一段：
三个组成部分的含义：*先验估计* $hat(x)_(n-1)$ 为获得新测量前的当前认知；*测量残差* $r_n = z_n - hat(x)_(n-1)$ 为观测值与先验的偏差；*增益系数* $K_n$ 控制残差对估计的修正幅度。这一"先验 + 增益 × 残差"的结构是递推估计的通用框架。


=== 从体重秤到赛车：静态估计的局限性

// 【修改 13】原因：开头重复引用公式不必要
// 原文："在第 1 章中，我们成功地用递推平均估计了体重：$hat(x)_n = ...$"
// 修改后：
递推平均能够有效估计静态量，是因为体重在测量过程中保持不变，所有偏差均可归因于传感器噪声。但对于动态系统，情况有所不同。

// 【修改 14】原因："然而，当我们将同样的方法应用于..."是冗余过渡
// 直接进入场景：
考虑追踪赛道上的赛车：起始位置 0 米，以 20 m/s 匀速行驶。GPS 每秒测量一次位置，误差 ±5 米。

真实轨迹为 $p_t = 20t$，GPS 测量值 $z_t = p_t + "噪声"$。

#figure(
table(
columns: (auto, auto, auto, auto, auto),
align: (center, center, center, center, center),
[*时刻 (s)*], [*真实位置 (m)*], [*GPS测量 (m)*], [*递推平均 (m)*], [*误差 (m)*],
[0], [0], [1.2], [1.2], [+1.2],
[1], [20], [18.3], [9.8], [−10.2],
[2], [40], [43.1], [20.9], [−19.1],
[3], [60], [56.8], [29.9], [−30.1],
[4], [80], [82.4], [40.4], [−39.6],
[5], [100], [97.6], [49.9], [−50.1],
),
caption: [递推平均追踪动态目标的失效]
)

// 【修改 15】原因："如表所示，估计值严重落后，且差距不断扩大。究其原因..."是AI总结套路
// 原文："如表所示，估计值严重落后，且差距不断扩大。究其原因，递推平均的公式结构..."
// 修改后：
估计误差随时间单调增大。问题在于递推平均的假设：被估计量保持不变。该公式将测量值的所有变化都视为噪声，无法区分噪声与真实的位置变化。

// 【修改 16】原因：原文用彩色框强调"只有修正，没有预测"，过于强调
// 修改为正文：
本质问题是：*递推平均只有修正，没有预测*。正确的思路应在获得新测量前，先根据运动规律预测当前位置，再用测量值修正。这正是 g-h 滤波器的核心思想。


==== g-h 滤波器

// 【修改 17】原因：彩色框"估计 = 预测 + 修正"可改为普通强调
对于运动物体，估计应包含预测步骤：

#align(center)[
  *估计 = 预测（运动模型）+ 修正（测量）*
]

// 【修改 18】原因："假设车辆是匀速运动的"可以更精炼
设在第 $k-1$ 时刻已有位置估计 $hat(p)_(k-1)$ 与速度估计 $hat(v)_(k-1)$。根据匀速运动模型，第 $k$ 时刻的预测为：

$ p_("pred",k) = hat(p)_(k-1) + hat(v)_(k-1) dot Delta t $
$ v_("pred",k) = hat(v)_(k-1) $

其中 $Delta t$ 为采样间隔。

// 【修改 19】原因：示例计算可保留但不需要单独标"示例"
若 $hat(p)_0 = 0$ m，$hat(v)_0 = 15$ m/s，$Delta t = 1$ s，则 $p_("pred",1) = 15$ m。

当测量值 $z_k$ 到来时，计算残差：

$ r_k = z_k - p_("pred",k) $

// 【修改 20】原因："接着，我们要对之前的预测值进行修正"是冗余过渡，删除
// 直接给出修正公式：

*位置修正*

$ hat(p)_k = p_("pred",k) + g dot r_k $

其中 $g in (0, 1)$ 为位置增益。$g = 0$ 表示完全信任预测，$g = 1$ 表示完全信任测量。

*速度修正*

$ hat(v)_k = v_("pred",k) + frac(h, Delta t) dot r_k $

其中 $h in (0, 1)$ 为速度增益。除以 $Delta t$ 是为了将位置残差（单位：m）转换为速度修正量（单位：m/s）。

// 【修改 21】原因：原文的note框解释"为什么除以Δt"过于啰嗦
// 已在上文简化说明，删除note框

// 【修改 22】原因：示例计算框删除，改为行内简述
以 $g = 0.3$，$h = 0.1$，$z_1 = 18.3$ m 为例：$r_1 = 3.3$ m，$hat(p)_1 = 15.99$ m，$hat(v)_1 = 15.33$ m/s。

// 【修改 23】原因：原文"观察"彩色框内容是显然的，删除
// 原文block删除

*g-h 滤波器算法*

#block(
  fill: rgb("#f5f5f5"),
  inset: 12pt,
  radius: 4pt,
)[
  *输入*：$hat(p)_(k-1)$，$hat(v)_(k-1)$，$z_k$，$Delta t$，$g$，$h$

  *预测*：
  $ p_("pred",k) = hat(p)_(k-1) + hat(v)_(k-1) Delta t, quad v_("pred",k) = hat(v)_(k-1) $

  *修正*：
  $ r_k = z_k - p_("pred",k) $
  $ hat(p)_k = p_("pred",k) + g r_k, quad hat(v)_k = v_("pred",k) + frac(h, Delta t) r_k $

  *输出*：$hat(p)_k$，$hat(v)_k$
]

// 【修改 24】原因：数值示例的逐步计算过于冗长，压缩为表格
// 原文"第1次迭代"、"第2次迭代"的详细展开删除

*数值示例*

参数：真实速度 20 m/s，$Delta t = 1$ s，$g = 0.3$，$h = 0.1$，初始估计 $hat(p)_0 = 0$，$hat(v)_0 = 15$（故意设为错误值）。

#figure(
table(
  columns: (auto, auto, auto, auto, auto, auto),
  align: center,
  [*t (s)*], [*真实位置*], [*GPS*], [*g-h估计*], [*真实速度*], [*速度估计*],
  [0], [0], [—], [0.0], [20], [15.00],
  [1], [20], [18.3], [16.0], [20], [15.33],
  [2], [40], [43.1], [34.9], [20], [16.51],
  [3], [60], [56.8], [54.3], [20], [17.68],
  [4], [80], [82.4], [74.8], [20], [18.73],
  [5], [100], [97.6], [96.0], [20], [19.60],
),
caption: [g-h 滤波器追踪结果]
)

// 【修改 25】原因："关键观察"彩色框改为正文
位置误差逐步收敛，速度估计自动逼近真实值，初始误差通过迭代修正被消除。

*递推平均与 g-h 滤波器对比*

#figure(
table(
  columns: (auto, auto, auto, auto),
  align: center,
  [*t (s)*], [*真实位置 (m)*], [*递推平均 (m)*], [*g-h (m)*],
  [0], [0], [1.2], [0.0],
  [1], [20], [9.8], [16.0],
  [2], [40], [20.9], [34.9],
  [3], [60], [29.9], [54.3],
  [4], [80], [40.4], [74.8],
  [5], [100], [49.9], [96.0],
),
caption: [同一数据下两种方法的对比]
)

// 【修改 26】原因：对比表格简化，删除冗余描述列
#table(
  columns: (auto, 1fr, 1fr),
  align: (center, left, left),
  [], [*递推平均*], [*g-h 滤波器*],
  [适用场景], [静态量], [动态系统],
  [预测机制], [无], [有（运动模型）],
  [状态数], [1], [2（位置+速度）],
  [增益], [$1/n$（递减）], [$g, h$（固定）],
  [第5秒误差], [50.1 m], [4.0 m],
)


==== 从标量到矩阵：为高维系统做准备

// 【修改 27】原因：开头"前面通过标量公式完整描述了..."是冗余回顾
// 修改后直接说明动机：
标量公式在一维场景下足够清晰，但对于高维系统会变得繁琐：

- 一维运动：$(p, v)$ — 2 个状态
- 二维平面：$(x, y, v_x, v_y)$ — 4 个状态
- 三维空间 + 加速度：9 个状态

// 【修改 28】原因："如果继续用标量公式...更糟糕的是...完全相同"过于口语化
// 修改后：
标量形式需要为每个状态单独写方程，而这些方程结构相同。矩阵形式可将其统一：无论状态维数如何，公式形式保持不变。

*状态向量*

// 【修改 29】原因：原文"第一步：将标量组织成向量"的步骤式表达过于教条
// 修改后直接给出定义：
定义状态向量 $bold(x)_k = vec(p_k, v_k)$ 与增益向量 $bold(K) = vec(g, h \/ Delta t)$。两个标量修正公式可合并为：

$ hat(bold(x))_k = bold(x)_("pred") + bold(K) dot (z_k - p_("pred")) $

// 【修改 30】原因：原文彩色框"关键观察"删除，内容合并到正文
增益向量的每一行对应一个状态的修正规则。

*观测矩阵*

// 【修改 31】原因："现在遇到一个问题..."的设问句式过于刻意
GPS 仅测量位置，无法测量速度。需要从状态向量中提取可观测分量，这由观测矩阵 $bold(H)$ 完成：

$ bold(H) = mat(1, 0) $

其作用为：

$ bold(H) bold(x)_("pred") = mat(1, 0) vec(p_("pred"), v_("pred")) = p_("pred") $

// 【修改 32】原因：原文彩色框"为什么需要H"的例子可精简
对于不同传感器配置，$bold(H)$ 的形式不同：
- 仅测位置：$bold(H) = mat(1, 0)$
- 仅测加速度：$bold(H) = mat(0, 0, 1)$
- 同时测位置和速度：$bold(H) = mat(1, 0; 0, 1)$

*完整的矩阵形式*

// 【修改 33】原因：彩色框改为普通公式块
$ hat(bold(x))_k = bold(x)_("pred") + bold(K) (z_k - bold(H) bold(x)_("pred")) $

// 【修改 34】原因：原文表格"公式各部分的物理意义"与前文重复，删除或精简
各项含义：$bold(x)_("pred")$ 为模型预测；$bold(H) bold(x)_("pred")$ 为预测对应的测量值；$z_k - bold(H) bold(x)_("pred")$ 为测量残差；$bold(K)$ 控制修正幅度。

*验证*

展开矩阵公式：

$ vec(hat(p)_k, hat(v)_k) &= vec(p_("pred"), v_("pred")) + vec(g, h \/ Delta t) (z_k - mat(1, 0) vec(p_("pred"), v_("pred"))) \
&= vec(p_("pred") + g(z_k - p_("pred")), v_("pred") + (h \/ Delta t)(z_k - p_("pred"))) $

与标量形式一致。

*预测步骤的矩阵形式*

定义状态转移矩阵：

$ bold(F) = mat(1, Delta t; 0, 1) $

预测步骤为 $bold(x)_("pred") = bold(F) hat(bold(x))_(k-1)$，展开后：

$ vec(p_("pred"), v_("pred")) = mat(1, Delta t; 0, 1) vec(hat(p)_(k-1), hat(v)_(k-1)) = vec(hat(p)_(k-1) + Delta t hat(v)_(k-1), hat(v)_(k-1)) $


==== 完整算法（矩阵形式）

// 【修改 35】原因：算法框保留，但颜色改为中性灰
#block(
  fill: rgb("#f5f5f5"),
  inset: 12pt,
  radius: 4pt,
)[
  *定义*：
  $ bold(x)_k = vec(p_k, v_k), quad bold(F) = mat(1, Delta t; 0, 1), quad bold(H) = mat(1, 0), quad bold(K) = vec(g, h \/ Delta t) $

  *预测*：$bold(x)_("pred") = bold(F) hat(bold(x))_(k-1)$

  *修正*：$hat(bold(x))_k = bold(x)_("pred") + bold(K) (z_k - bold(H) bold(x)_("pred"))$
]


==== g-h 滤波器的局限性

// 【修改 36】原因：原文"g-h滤波器已经具备了现代滤波器的基本结构"可更简洁
g-h 滤波器具备"预测 + 修正"的基本结构，但增益 $g$、$h$ 需手动设定。卡尔曼滤波通过以下机制解决这一问题：

+ 引入误差协方差矩阵 $bold(P)_k$ 量化估计的不确定性
+ 根据最小化估计误差的准则，动态计算最优增益 $bold(K)_k$

下一章将推导这一机制的数学原理。


=== 最优增益的推导

上一章建立了 g-h 滤波器的基本框架，其核心公式为：

$ hat(x)_k = x_("pred") + K (z_k - x_("pred")) $

该公式的结构清晰：预测值与测量值的加权融合，增益 $K$ 控制两者的权重分配。然而，$K$ 的取值从何而来？在 g-h 滤波器中，$g$ 和 $h$ 由工程师根据经验手动设定，这显然不是最优解。本章将从概率的角度重新审视状态估计问题，推导出增益的最优取值，这正是卡尔曼滤波的核心贡献。

==== 不确定性的量化

在讨论"最优"之前，需要明确优化的目标。回到赛车追踪的场景：预测位置为 35 米，GPS 测量值为 38 米，最终估计应该取多少？

g-h 滤波器的回答是：取决于你设定的 $g$ 值。若 $g = 0.3$，则估计为 $35 + 0.3 times (38 - 35) = 35.9$ 米。但这个答案回避了一个关键问题——凭什么选 $g = 0.3$？

更合理的思路是考虑预测和测量各自的可信程度。如果运动模型非常精确（比如赛车在笔直赛道上匀速行驶），预测值应当更可信；如果 GPS 精度很高而模型存在较大不确定性，测量值应当更可信。这种"可信程度"需要用数学语言精确描述，而方差正是刻画不确定性的自然工具。

设预测值 $x_("pred")$ 的误差服从均值为零、方差为 $sigma_("pred")^2$ 的分布，测量值 $z$ 的误差服从均值为零、方差为 $sigma_z^2$ 的分布。方差越大，对应的值越不可信。现在，优化目标可以明确表述为：选择增益 $K$，使得融合后的估计 $hat(x)$ 具有最小的误差方差。

==== 两个估计的最优融合

为简化推导，先考虑一个更基本的问题：有两个对同一量 $x$ 的独立估计 $x_1$ 和 $x_2$，误差方差分别为 $sigma_1^2$ 和 $sigma_2^2$，如何将它们融合为一个更精确的估计？

自然的想法是加权平均：

$ hat(x) = w_1 x_1 + w_2 x_2, quad w_1 + w_2 = 1 $

设 $w_1 = 1 - K$，$w_2 = K$，则：

$ hat(x) = (1 - K) x_1 + K x_2 = x_1 + K(x_2 - x_1) $

这与滤波器的修正公式形式完全一致。接下来推导使 $hat(x)$ 方差最小的 $K$ 值。

设 $x_1 = x + epsilon_1$，$x_2 = x + epsilon_2$，其中 $epsilon_1$、$epsilon_2$ 为零均值、相互独立的误差项，方差分别为 $sigma_1^2$、$sigma_2^2$。融合估计的误差为：

$ hat(x) - x = (1-K)(x + epsilon_1) + K(x + epsilon_2) - x = (1-K)epsilon_1 + K epsilon_2 $

由于 $epsilon_1$ 与 $epsilon_2$ 独立，误差方差为：

$ sigma_(hat(x))^2 = (1-K)^2 sigma_1^2 + K^2 sigma_2^2 $

对 $K$ 求导并令其为零：

$ frac(d sigma_(hat(x))^2, d K) = -2(1-K)sigma_1^2 + 2K sigma_2^2 = 0 $

解得：

$ K^* = frac(sigma_1^2, sigma_1^2 + sigma_2^2) $

这一结果具有直观的解释：最优增益与 $x_1$ 的方差成正比，与 $x_2$ 的方差成反比。换言之，越不可信的估计，其权重越低。当 $sigma_1^2 >> sigma_2^2$ 时，$K^* approx 1$，融合结果接近 $x_2$；当 $sigma_1^2 << sigma_2^2$ 时，$K^* approx 0$，融合结果接近 $x_1$。

将最优增益代回方差公式，可得融合后的方差：

$ sigma_(hat(x))^2 = (1 - K^*)sigma_1^2 = frac(sigma_1^2 sigma_2^2, sigma_1^2 + sigma_2^2) $

注意到 $sigma_(hat(x))^2 < min(sigma_1^2, sigma_2^2)$，即融合后的估计总是比任一单独估计更精确。这正是信息融合的价值所在。

==== 卡尔曼增益的形式

回到滤波器的语境，$x_1$ 对应预测值 $x_("pred")$，$x_2$ 对应测量值 $z$。将符号替换后，最优增益为：

$ K = frac(sigma_("pred")^2, sigma_("pred")^2 + sigma_z^2) $

这就是一维卡尔曼增益的表达式。其行为与直觉一致：

- 若预测不确定性大（$sigma_("pred")^2$ 大），$K$ 接近 1，更信任测量
- 若测量噪声大（$sigma_z^2$ 大），$K$ 接近 0，更信任预测
- 两者相当时，$K approx 0.5$，各取一半

与 g-h 滤波器的固定增益不同，卡尔曼增益随不确定性的变化而动态调整。在滤波器运行初期，状态估计的不确定性通常较大，此时 $K$ 较大，测量值对估计的影响显著；随着观测数据的积累，估计逐渐收敛，$sigma_("pred")^2$ 减小，$K$ 随之下降，新测量的影响减弱。这种自适应特性是卡尔曼滤波的核心优势。

==== 不确定性的传播

卡尔曼增益的计算依赖于 $sigma_("pred")^2$，而 $sigma_("pred")^2$ 又从何而来？这需要追踪不确定性在预测和修正两个阶段的演变。

*预测阶段的不确定性增长*

考虑匀速运动模型 $x_k = x_(k-1) + v Delta t$。即使上一时刻的位置估计是准确的，模型本身也存在误差——赛车可能轻微加速或减速，这种模型不确定性称为过程噪声，记其方差为 $sigma_w^2$。

设第 $k-1$ 时刻的估计方差为 $sigma_(k-1)^2$。由于位置预测直接继承了上一时刻的估计（$x_("pred") = hat(x)_(k-1) + hat(v) Delta t$），预测误差包含两部分：上一时刻的估计误差和过程噪声。假设两者独立，预测方差为：

$ sigma_("pred")^2 = sigma_(k-1)^2 + sigma_w^2 $

这一公式说明，预测阶段的不确定性总是增加——即使此前的估计很精确，模型误差也会使不确定性累积。

*修正阶段的不确定性减小*

当新测量到来后，融合公式降低了不确定性。由前面的推导，修正后的方差为：

$ sigma_k^2 = (1 - K) sigma_("pred")^2 = frac(sigma_("pred")^2 sigma_z^2, sigma_("pred")^2 + sigma_z^2) $

由于 $0 < K < 1$，修正后的方差总是小于预测方差。每次测量都带来新信息，使估计更加确定。

将增益公式代入，修正后的方差也可写为：

$ sigma_k^2 = (1 - K) sigma_("pred")^2 $

这一形式在计算上更为简洁，将在后续的多维推广中使用。

==== 一维卡尔曼滤波算法

综合以上推导，一维卡尔曼滤波的完整算法如下。设系统状态为位置 $x$，状态转移方程为 $x_k = x_(k-1) + u_k + w_k$，其中 $u_k$ 为已知控制量（如速度乘以时间），$w_k$ 为过程噪声。测量方程为 $z_k = x_k + v_k$，其中 $v_k$ 为测量噪声。

*初始化*

设定初始估计 $hat(x)_0$ 和初始方差 $sigma_0^2$。若对初始状态一无所知，可将 $sigma_0^2$ 设为较大值。

*预测*

$ x_("pred") = hat(x)_(k-1) + u_k $
$ sigma_("pred")^2 = sigma_(k-1)^2 + sigma_w^2 $

*修正*

$ K_k = frac(sigma_("pred")^2, sigma_("pred")^2 + sigma_z^2) $
$ hat(x)_k = x_("pred") + K_k (z_k - x_("pred")) $
$ sigma_k^2 = (1 - K_k) sigma_("pred")^2 $

算法在预测与修正之间交替进行，每一步都输出状态估计 $hat(x)_k$ 及其不确定性 $sigma_k^2$。与 g-h 滤波器相比，核心区别在于增益 $K_k$ 不再是预设常数，而是根据当前不确定性动态计算。

==== 数值示例：重新追踪赛车

沿用上一章的赛车场景，但改用卡尔曼滤波进行估计。参数设定如下：

- 过程噪声标准差：$sigma_w = 1$ m（模型不完全准确）
- 测量噪声标准差：$sigma_z = 5$ m（GPS 精度有限）
- 初始估计：$hat(x)_0 = 0$ m
- 初始标准差：$sigma_0 = 10$ m（对初始位置不确定）
- 控制量：$u_k = 20$ m（真实速度 20 m/s，$Delta t = 1$ s）

#figure(
table(
  columns: (auto, auto, auto, auto, auto, auto, auto),
  align: center,
  [*t (s)*], [*真实*], [*预测*], [*$sigma_("pred")$*], [*测量*], [*$K$*], [*估计*], 
  [0], [0], [—], [—], [—], [—], [0.0],
  [1], [20], [20.0], [10.0], [18.3], [0.80], [18.6],
  [2], [40], [38.6], [4.5], [43.1], [0.45], [40.6],
  [3], [60], [60.6], [2.1], [56.8], [0.15], [60.0],
  [4], [80], [80.0], [1.5], [82.4], [0.08], [80.2],
  [5], [100], [100.2], [1.3], [97.6], [0.06], [100.0],
),
caption: [一维卡尔曼滤波追踪赛车]
)

#note("第1步计算过程")[
预测：$x_("pred") = 0 + 20 = 20$ m

预测方差：$sigma_("pred")^2 = 10^2 + 1^2 = 101$，$sigma_("pred") approx 10.0$ m

卡尔曼增益：$K = 101 / (101 + 25) = 0.80$

修正：$hat(x)_1 = 20 + 0.80 times (18.3 - 20) = 18.6$ m

修正方差：$sigma_1^2 = (1 - 0.80) times 101 = 20.2$，$sigma_1 approx 4.5$ m
]

从表中可以观察到几个重要现象。首先，卡尔曼增益 $K$ 从初始的 0.80 逐步下降到 0.06。这是因为随着观测数据的积累，估计的不确定性 $sigma_("pred")$ 不断减小，滤波器对新测量的依赖程度降低。其次，预测标准差从 10 m 迅速收敛到约 1.3 m，说明滤波器在几步之内就建立了对状态的可靠估计。最后，第 5 秒的估计误差仅为 0.0 m，远优于 g-h 滤波器的 4.0 m 和递推平均的 50.1 m。

这一改进的根源在于：卡尔曼滤波根据实际的不确定性水平自动调整增益，而非使用固定权重。当估计不确定时（初始阶段），大量采纳测量信息；当估计已经可靠时，对异常测量保持适度怀疑。

==== 从 g-h 滤波器到卡尔曼滤波

至此，可以清晰地看出 g-h 滤波器与卡尔曼滤波的关系。两者共享相同的修正公式：

$ hat(x)_k = x_("pred") + K (z_k - x_("pred")) $

差异在于增益的来源：

#table(
  columns: (auto, 1fr, 1fr),
  align: (center, left, left),
  [], [*g-h 滤波器*], [*卡尔曼滤波*],
  [增益], [手动设定常数 $g$], [动态计算 $K_k = sigma_("pred")^2 / (sigma_("pred")^2 + sigma_z^2)$],
  [依据], [工程经验], [最小化估计误差方差],
  [自适应], [无], [有（增益随不确定性变化）],
  [额外输出], [无], [估计的不确定性 $sigma_k^2$],
)

卡尔曼滤波可视为 g-h 滤波器的最优化版本：在相同的"预测-修正"框架下，通过概率推理自动确定最优增益。此外，卡尔曼滤波还输出估计的不确定性，这在实际应用中极为重要——它告诉我们估计结果有多可信。

==== 本章小结

本章从优化的角度重新审视了状态估计问题，得到以下核心结论：

状态估计的目标是最小化估计误差的方差。当预测和测量各自携带不确定性时，最优融合策略是根据方差进行加权：方差越大的估计，权重越低。由此导出的卡尔曼增益 $K = sigma_("pred")^2 / (sigma_("pred")^2 + sigma_z^2)$ 具有清晰的物理意义——它平衡了模型预测与传感器测量之间的信任程度。

不确定性在预测阶段增长（因为模型不完美），在修正阶段减小（因为测量提供新信息）。卡尔曼滤波的递推结构正是在这两个过程之间交替，持续追踪状态估计及其不确定性。

目前的推导限于一维情形。下一章将把这些概念推广到多维系统，届时方差将被协方差矩阵取代，增益将成为矩阵，但核心思想——基于不确定性的最优融合——保持不变。


=== 多维卡尔曼滤波

上一章在一维情形下完成了卡尔曼滤波的推导，核心结论是：最优增益由预测方差与测量方差的比值决定，融合后的估计具有最小的误差方差。然而，实际系统往往涉及多个相互关联的状态量。以赛车追踪为例，完整描述其运动状态至少需要位置和速度两个变量；若在二维平面上追踪，则需要 $(x, y, v_x, v_y)$ 四个状态。本章将一维结论推广到多维情形，建立完整的卡尔曼滤波方程组。

==== 为什么需要协方差矩阵

在一维情形下，估计的不确定性用单个方差 $sigma^2$ 描述。推广到多维时，一个自然的想法是为每个状态分量分别记录方差。例如，对于状态向量 $bold(x) = vec(p, v)$，分别记录位置方差 $sigma_p^2$ 和速度方差 $sigma_v^2$。

这种做法忽略了一个重要现象：状态分量之间往往存在相关性。考虑以下场景：若当前位置被高估（真实位置比估计值低），根据 $p = p_0 + v t$ 的关系，很可能速度也被高估了。换言之，位置误差和速度误差并非独立，而是倾向于同向偏离。

协方差正是刻画这种相关性的工具。对于两个随机变量 $X$ 和 $Y$，协方差定义为：

$ "Cov"(X, Y) = E[(X - mu_X)(Y - mu_Y)] $

若 $X$ 和 $Y$ 倾向于同向偏离各自的均值，协方差为正；若倾向于反向偏离，协方差为负；若两者独立，协方差为零。方差是协方差的特例：$"Var"(X) = "Cov"(X, X)$。

对于 $n$ 维状态向量 $bold(x) = vec(x_1, x_2, dots.v, x_n)$，所有方差和协方差可组织成一个 $n times n$ 的对称矩阵：

$ bold(P) = mat(
  "Var"(x_1), "Cov"(x_1, x_2), dots, "Cov"(x_1, x_n);
  "Cov"(x_2, x_1), "Var"(x_2), dots, "Cov"(x_2, x_n);
  dots.v, dots.v, dots.down, dots.v;
  "Cov"(x_n, x_1), "Cov"(x_n, x_2), dots, "Var"(x_n)
) $

这就是协方差矩阵。对角线元素是各状态的方差，非对角线元素是状态之间的协方差。以位置-速度系统为例：

$ bold(P) = mat(
  sigma_p^2, sigma_(p v);
  sigma_(p v), sigma_v^2
) $

其中 $sigma_(p v) = "Cov"(p, v)$ 描述位置误差与速度误差的相关程度。若 $sigma_(p v) > 0$，表示位置被高估时速度也倾向于被高估。

协方差矩阵在卡尔曼滤波中扮演核心角色：它不仅记录各状态的不确定性大小，还记录状态之间的误差关联。后者对于提高估计精度至关重要——当测量修正了某个状态时，与之相关的其他状态也应当相应调整。

==== 多维系统的数学描述

在建立滤波方程之前，需要明确多维系统的数学模型。

*状态转移方程*

系统状态从第 $k-1$ 时刻演变到第 $k$ 时刻的规律由状态转移方程描述：

$ bold(x)_k = bold(F) bold(x)_(k-1) + bold(B) bold(u)_k + bold(w)_k $

其中 $bold(F)$ 是状态转移矩阵，描述状态的自然演化；$bold(B)$ 是控制矩阵，$bold(u)_k$ 是控制输入；$bold(w)_k$ 是过程噪声，代表模型的不确定性。

以匀速运动模型为例，状态为 $bold(x) = vec(p, v)$，状态转移方程为：

$ vec(p_k, v_k) = mat(1, Delta t; 0, 1) vec(p_(k-1), v_(k-1)) + vec(w_p, w_v) $

状态转移矩阵 $bold(F) = mat(1, Delta t; 0, 1)$ 的含义是：新位置 = 旧位置 + 速度 $times$ 时间，新速度 = 旧速度（匀速假设）。

过程噪声 $bold(w)_k$ 通常假设服从零均值高斯分布，其协方差矩阵记为 $bold(Q)$：

$ bold(w)_k tilde cal(N)(bold(0), bold(Q)) $

$bold(Q)$ 的大小反映模型的可靠程度。若系统严格遵循模型（如匀速运动），$bold(Q)$ 较小；若模型仅为粗略近似，$bold(Q)$ 较大。

*观测方程*

传感器测量与系统状态的关系由观测方程描述：

$ bold(z)_k = bold(H) bold(x)_k + bold(v)_k $

其中 $bold(H)$ 是观测矩阵，将状态空间映射到测量空间；$bold(v)_k$ 是测量噪声，协方差矩阵记为 $bold(R)$。

继续位置-速度的例子。若传感器仅能测量位置，观测方程为：

$ z_k = mat(1, 0) vec(p_k, v_k) + v_k $

观测矩阵 $bold(H) = mat(1, 0)$ 表示从状态向量中提取位置分量。测量噪声方差 $bold(R) = sigma_z^2$ 反映传感器精度。

==== 预测阶段

卡尔曼滤波的每一步分为预测和修正两个阶段。预测阶段根据系统模型推算下一时刻的状态及其不确定性。

*状态预测*

状态预测直接应用状态转移方程（忽略噪声项，因为噪声均值为零）：

$ bold(x)_(k|k-1) = bold(F) bold(x)_(k-1) + bold(B) bold(u)_k $

下标 $k|k-1$ 表示"基于前 $k-1$ 时刻信息对第 $k$ 时刻的预测"。

*协方差预测*

不确定性的传播稍显复杂。设第 $k-1$ 时刻的估计协方差为 $bold(P)_(k-1)$，需要推导预测协方差 $bold(P)_(k|k-1)$。

状态预测误差为：

$ bold(x)_k - bold(x)_(k|k-1) = bold(F)(bold(x)_(k-1) - hat(bold(x))_(k-1)) + bold(w)_k $

等号右边第一项是上一时刻估计误差经 $bold(F)$ 变换的结果，第二项是过程噪声。由于估计误差与过程噪声独立，预测协方差为：

$ bold(P)_(k|k-1) = bold(F) bold(P)_(k-1) bold(F)^top + bold(Q) $

这一公式的含义是：预测不确定性来自两部分——上一时刻的估计不确定性（经状态转移放大或缩小）和模型本身的不确定性（过程噪声）。即使 $bold(P)_(k-1)$ 很小，$bold(Q)$ 的存在也会使 $bold(P)_(k|k-1)$ 增大，这与一维情形中"预测阶段方差增加"的结论一致。

#note("协方差变换公式")[
若随机向量 $bold(x)$ 的协方差矩阵为 $bold(P)$，则线性变换 $bold(y) = bold(A) bold(x)$ 的协方差矩阵为 $bold(A) bold(P) bold(A)^top$。

证明：设 $bold(x)$ 的均值为 $bold(mu)$，则

$ "Cov"(bold(y)) = E[(bold(A) bold(x) - bold(A) bold(mu))(bold(A) bold(x) - bold(A) bold(mu))^top] = bold(A) E[(bold(x) - bold(mu))(bold(x) - bold(mu))^top] bold(A)^top = bold(A) bold(P) bold(A)^top $
]

==== 修正阶段

当新测量 $bold(z)_k$ 到来时，修正阶段将预测与测量融合，得到更精确的估计。

*卡尔曼增益*

多维卡尔曼增益的推导遵循与一维相同的原则：最小化修正后的估计误差协方差。推导过程涉及矩阵求导，此处直接给出结果：

$ bold(K)_k = bold(P)_(k|k-1) bold(H)^top (bold(H) bold(P)_(k|k-1) bold(H)^top + bold(R))^(-1) $

这一公式的结构与一维情形对应。分子 $bold(P)_(k|k-1) bold(H)^top$ 反映预测不确定性在测量空间的投影；分母 $bold(H) bold(P)_(k|k-1) bold(H)^top + bold(R)$ 是预测测量的不确定性（来自状态预测）与测量本身的不确定性（来自传感器）之和。当预测不确定性大时，$bold(K)$ 较大，更信任测量；当测量不确定性大时，$bold(K)$ 较小，更信任预测。

*状态修正*

修正公式与 g-h 滤波器形式相同：

$ hat(bold(x))_k = bold(x)_(k|k-1) + bold(K)_k (bold(z)_k - bold(H) bold(x)_(k|k-1)) $

括号内的 $bold(z)_k - bold(H) bold(x)_(k|k-1)$ 称为测量残差或新息（Innovation），表示实际测量与预测测量之间的偏差。卡尔曼增益决定了这一偏差如何分配到各个状态分量上。

*协方差修正*

修正后的协方差为：

$ bold(P)_k = (bold(I) - bold(K)_k bold(H)) bold(P)_(k|k-1) $

其中 $bold(I)$ 为单位矩阵。这一公式表明，测量总是减小不确定性——$bold(I) - bold(K)_k bold(H)$ 的特征值均小于 1，因此 $bold(P)_k$ 在各方向上都不大于 $bold(P)_(k|k-1)$。

==== 完整算法

综合预测和修正阶段，多维卡尔曼滤波的完整算法如下。

#block(
  fill: rgb("#f5f5f5"),
  inset: 12pt,
  radius: 4pt,
)[
*系统模型*

状态转移：$bold(x)_k = bold(F) bold(x)_(k-1) + bold(B) bold(u)_k + bold(w)_k$，$bold(w)_k tilde cal(N)(bold(0), bold(Q))$

观测方程：$bold(z)_k = bold(H) bold(x)_k + bold(v)_k$，$bold(v)_k tilde cal(N)(bold(0), bold(R))$

*初始化*

初始状态估计 $hat(bold(x))_0$，初始协方差 $bold(P)_0$

*预测*

$ bold(x)_(k|k-1) = bold(F) hat(bold(x))_(k-1) + bold(B) bold(u)_k $
$ bold(P)_(k|k-1) = bold(F) bold(P)_(k-1) bold(F)^top + bold(Q) $

*修正*

$ bold(K)_k = bold(P)_(k|k-1) bold(H)^top (bold(H) bold(P)_(k|k-1) bold(H)^top + bold(R))^(-1) $
$ hat(bold(x))_k = bold(x)_(k|k-1) + bold(K)_k (bold(z)_k - bold(H) bold(x)_(k|k-1)) $
$ bold(P)_k = (bold(I) - bold(K)_k bold(H)) bold(P)_(k|k-1) $
]

算法在预测与修正之间交替进行，每一步输出状态估计 $hat(bold(x))_k$ 及其协方差 $bold(P)_k$。协方差矩阵不仅用于计算下一步的卡尔曼增益，还直接提供了估计的置信区间。

==== 示例：一维位置-速度系统

为了具体展示多维卡尔曼滤波的运算过程，回到赛车追踪问题。此前我们假设速度已知（作为控制输入），现在将速度也作为待估计的状态，考察滤波器能否从位置测量中同时恢复位置和速度。

*系统设定*

状态向量 $bold(x) = vec(p, v)$，真实初始状态为 $vec(0, 20)$（位置 0 m，速度 20 m/s）。

状态转移矩阵（匀速模型，$Delta t = 1$ s）：

$ bold(F) = mat(1, 1; 0, 1) $

观测矩阵（仅测量位置）：

$ bold(H) = mat(1, 0) $

过程噪声协方差（速度可能有小幅波动）：

$ bold(Q) = mat(0.25, 0.5; 0.5, 1) $

测量噪声方差：

$ bold(R) = mat(25) quad (sigma_z = 5 "m") $

初始估计（故意设定错误的速度）：

$ hat(bold(x))_0 = vec(0, 15), quad bold(P)_0 = mat(100, 0; 0, 100) $

*第 1 步迭代*

预测：

$ bold(x)_(1|0) = mat(1, 1; 0, 1) vec(0, 15) = vec(15, 15) $

$ bold(P)_(1|0) = mat(1, 1; 0, 1) mat(100, 0; 0, 100) mat(1, 0; 1, 1) + mat(0.25, 0.5; 0.5, 1) = mat(200.25, 100.5; 100.5, 101) $

卡尔曼增益：

$ bold(H) bold(P)_(1|0) bold(H)^top + bold(R) = 200.25 + 25 = 225.25 $

$ bold(K)_1 = mat(200.25; 100.5) times 1/225.25 = mat(0.889; 0.446) $

测量 $z_1 = 18.3$ m，修正：

$ hat(bold(x))_1 = vec(15, 15) + mat(0.889; 0.446) times (18.3 - 15) = vec(17.9, 16.5) $

$ bold(P)_1 = (mat(1, 0; 0, 1) - mat(0.889; 0.446) mat(1, 0)) mat(200.25, 100.5; 100.5, 101) = mat(22.2, 11.2; 11.2, 56.2) $

*完整追踪结果*

#figure(
table(
  columns: (auto, auto, auto, auto, auto, auto, auto),
  align: center,
  [*t*], [*真实位置*], [*真实速度*], [*测量*], [*位置估计*], [*速度估计*], [*$sigma_p$*],
  [0], [0], [20], [—], [0.0], [15.0], [10.0],
  [1], [20], [20], [18.3], [17.9], [16.5], [4.7],
  [2], [40], [20], [43.1], [39.8], [18.7], [3.5],
  [3], [60], [20], [56.8], [59.2], [19.4], [3.0],
  [4], [80], [20], [82.4], [80.0], [19.8], [2.7],
  [5], [100], [20], [97.6], [99.7], [19.9], [2.5],
),
caption: [多维卡尔曼滤波追踪结果]
)

从结果中可以看到，尽管传感器只能测量位置，滤波器却成功地同时估计了位置和速度。速度估计从初始的 15 m/s 逐步收敛到接近真实值 20 m/s，这正是协方差矩阵发挥作用的结果——位置测量残差通过 $sigma_(p v)$ 的关联传递到速度估计上。

位置估计的标准差从 10 m 下降到 2.5 m，表明不确定性持续减小。若继续迭代，标准差将收敛到一个稳态值，由过程噪声 $bold(Q)$ 和测量噪声 $bold(R)$ 的相对大小决定。

==== 矩阵维度总结

多维卡尔曼滤波涉及多个矩阵，初学者容易混淆其维度。设状态向量维度为 $n$，测量向量维度为 $m$，控制向量维度为 $l$，各矩阵的维度如下：

#table(
  columns: (auto, auto, auto),
  align: (center, center, left),
  [*符号*], [*维度*], [*含义*],
  [$bold(x)$], [$n times 1$], [状态向量],
  [$bold(z)$], [$m times 1$], [测量向量],
  [$bold(u)$], [$l times 1$], [控制向量],
  [$bold(F)$], [$n times n$], [状态转移矩阵],
  [$bold(B)$], [$n times l$], [控制矩阵],
  [$bold(H)$], [$m times n$], [观测矩阵],
  [$bold(Q)$], [$n times n$], [过程噪声协方差],
  [$bold(R)$], [$m times m$], [测量噪声协方差],
  [$bold(P)$], [$n times n$], [状态估计协方差],
  [$bold(K)$], [$n times m$], [卡尔曼增益],
)

卡尔曼增益 $bold(K)$ 的维度 $n times m$ 值得注意：它将 $m$ 维的测量残差映射到 $n$ 维的状态修正。即使测量维度低于状态维度（如本例中 $m = 1$，$n = 2$），滤波器仍能通过协方差的关联信息更新所有状态。

==== 本章小结

本章将一维卡尔曼滤波推广到多维情形。核心概念的对应关系如下：

#table(
  columns: (auto, 1fr, 1fr),
  align: (center, left, left),
  [], [*一维*], [*多维*],
  [状态], [$x$], [$bold(x)$ （向量）],
  [不确定性], [$sigma^2$ （方差）], [$bold(P)$ （协方差矩阵）],
  [增益], [$K = sigma_("pred")^2 / (sigma_("pred")^2 + sigma_z^2)$], [$bold(K) = bold(P)_(k|k-1) bold(H)^top (bold(H) bold(P)_(k|k-1) bold(H)^top + bold(R))^(-1)$],
  [预测方差], [$sigma_("pred")^2 = sigma_(k-1)^2 + sigma_w^2$], [$bold(P)_(k|k-1) = bold(F) bold(P)_(k-1) bold(F)^top + bold(Q)$],
  [修正方差], [$sigma_k^2 = (1 - K) sigma_("pred")^2$], [$bold(P)_k = (bold(I) - bold(K) bold(H)) bold(P)_(k|k-1)$],
)

多维形式的本质与一维相同：预测阶段不确定性增加，修正阶段不确定性减小，卡尔曼增益平衡预测与测量的信任程度。协方差矩阵的引入使滤波器能够利用状态之间的关联信息，即使某些状态不能直接测量（如速度），也可以通过与可测状态（如位置）的相关性间接估计。

至此，线性卡尔曼滤波的理论框架已经完整。然而，上述推导依赖一个关键假设：状态转移和观测方程都是线性的。当系统存在非线性时——例如雷达以极坐标测量目标位置——标准卡尔曼滤波不再适用。下一章将介绍扩展卡尔曼滤波（EKF），它通过局部线性化处理非线性系统。



=== 扩展卡尔曼滤波

前两章建立的卡尔曼滤波理论依赖于线性假设：状态转移方程 $bold(x)_k = bold(F) bold(x)_(k-1)$ 和观测方程 $bold(z)_k = bold(H) bold(x)_k$ 都是状态的线性函数。这一假设在许多场景下是合理的——匀速运动、弹簧振子、电路系统等都可以用线性方程描述。然而，现实中大量系统本质上是非线性的。本章将分析线性假设的局限性，并介绍扩展卡尔曼滤波（Extended Kalman Filter, EKF）如何通过局部线性化处理非线性系统。

==== 非线性系统的例子

考虑一个典型的雷达追踪问题。雷达站位于原点，追踪一架在二维平面上飞行的飞机。飞机的状态用直角坐标描述：

$ bold(x) = vec(x, y, v_x, v_y) $

其中 $(x, y)$ 是位置，$(v_x, v_y)$ 是速度。假设飞机做匀速直线运动，状态转移方程为：

$ vec(x_k, y_k, v_(x,k), v_(y,k)) = mat(1, 0, Delta t, 0; 0, 1, 0, Delta t; 0, 0, 1, 0; 0, 0, 0, 1) vec(x_(k-1), y_(k-1), v_(x,k-1), v_(y,k-1)) $

这是标准的线性方程，没有问题。困难出在观测方程上。

雷达并不直接测量飞机的直角坐标 $(x, y)$，而是测量极坐标：距离 $r$ 和方位角 $theta$。测量值与状态的关系为：

$ r = sqrt(x^2 + y^2) $
$ theta = arctan(y / x) $

或写成向量形式：

$ bold(z) = vec(r, theta) = vec(sqrt(x^2 + y^2), arctan(y \/ x)) $

这是一个非线性观测方程——测量值不是状态的线性组合，无法写成 $bold(z) = bold(H) bold(x)$ 的形式。平方根和反正切函数破坏了线性结构。

非线性带来的问题是什么？回顾卡尔曼滤波的核心假设：状态估计的不确定性用高斯分布描述，而高斯分布经过线性变换后仍然是高斯分布。这一性质保证了预测和修正阶段的协方差计算是精确的。

但高斯分布经过非线性变换后通常不再是高斯分布。考虑一个简单的例子：若 $x tilde cal(N)(0, 1)$，则 $y = x^2$ 的分布是卡方分布，不是高斯分布。这意味着，当观测方程非线性时，直接套用卡尔曼滤波公式会产生系统性误差。

==== 线性化的思想

扩展卡尔曼滤波的核心思想是：既然无法处理非线性函数，就用线性函数来近似它。具体方法是在当前估计点对非线性函数进行泰勒展开，保留一阶项。

设非线性函数为 $bold(h)(bold(x))$，在点 $bold(x)_0$ 处展开：

$ bold(h)(bold(x)) approx bold(h)(bold(x)_0) + frac(partial bold(h), partial bold(x))|_(bold(x)_0) (bold(x) - bold(x)_0) $

一阶导数 $frac(partial bold(h), partial bold(x))$ 是一个矩阵，称为雅可比矩阵（Jacobian），记为 $bold(J)$。对于 $m$ 维输出、$n$ 维输入的函数，雅可比矩阵的维度是 $m times n$，第 $(i, j)$ 元素为 $frac(partial h_i, partial x_j)$。

以雷达观测为例，观测函数 $bold(h)(bold(x)) = vec(sqrt(x^2 + y^2), arctan(y\/x))$ 对状态 $bold(x) = vec(x, y, v_x, v_y)$ 的雅可比矩阵为：

$ bold(H)_k = frac(partial bold(h), partial bold(x)) = mat(
  frac(partial r, partial x), frac(partial r, partial y), frac(partial r, partial v_x), frac(partial r, partial v_y);
  frac(partial theta, partial x), frac(partial theta, partial y), frac(partial theta, partial v_x), frac(partial theta, partial v_y)
) $

由于 $r$ 和 $theta$ 都不依赖于速度 $(v_x, v_y)$，后两列为零。计算非零偏导数：

$ frac(partial r, partial x) = frac(x, sqrt(x^2 + y^2)) = frac(x, r), quad frac(partial r, partial y) = frac(y, r) $

$ frac(partial theta, partial x) = frac(-y \/ x^2, 1 + (y\/x)^2) = frac(-y, x^2 + y^2) = frac(-y, r^2), quad frac(partial theta, partial y) = frac(1\/x, 1 + (y\/x)^2) = frac(x, r^2) $

因此，雅可比矩阵为：

$ bold(H)_k = mat(
  x\/r, y\/r, 0, 0;
  -y\/r^2, x\/r^2, 0, 0
) $

这个矩阵在当前状态估计 $(hat(x), hat(y))$ 处计算，因此是时变的——每一步都需要重新计算。这是 EKF 与标准卡尔曼滤波的关键区别：标准卡尔曼滤波中 $bold(H)$ 是常数，EKF 中 $bold(H)_k$ 随估计值变化。

==== 扩展卡尔曼滤波算法

将线性化思想应用到卡尔曼滤波的各个阶段，得到 EKF 算法。设非线性状态转移方程为 $bold(x)_k = bold(f)(bold(x)_(k-1), bold(u)_k) + bold(w)_k$，非线性观测方程为 $bold(z)_k = bold(h)(bold(x)_k) + bold(v)_k$。

*预测阶段*

状态预测使用非线性函数：

$ bold(x)_(k|k-1) = bold(f)(hat(bold(x))_(k-1), bold(u)_k) $

协方差预测需要状态转移函数的雅可比矩阵 $bold(F)_k = frac(partial bold(f), partial bold(x))|_(hat(bold(x))_(k-1))$：

$ bold(P)_(k|k-1) = bold(F)_k bold(P)_(k-1) bold(F)_k^top + bold(Q) $

注意状态预测直接用非线性函数计算（保持精度），而协方差传播用线性化后的雅可比矩阵（便于计算）。

*修正阶段*

卡尔曼增益使用观测函数的雅可比矩阵 $bold(H)_k = frac(partial bold(h), partial bold(x))|_(bold(x)_(k|k-1))$：

$ bold(K)_k = bold(P)_(k|k-1) bold(H)_k^top (bold(H)_k bold(P)_(k|k-1) bold(H)_k^top + bold(R))^(-1) $

状态修正使用非线性观测函数计算预测测量：

$ hat(bold(x))_k = bold(x)_(k|k-1) + bold(K)_k (bold(z)_k - bold(h)(bold(x)_(k|k-1))) $

协方差修正：

$ bold(P)_k = (bold(I) - bold(K)_k bold(H)_k) bold(P)_(k|k-1) $

整个算法的流程与标准卡尔曼滤波相同，核心区别有两点：第一，状态预测和测量预测使用原始的非线性函数；第二，协方差传播和增益计算使用在当前估计点计算的雅可比矩阵。

#block(
  fill: rgb("#f5f5f5"),
  inset: 12pt,
  radius: 4pt,
)[
*EKF 算法*

*系统模型*

状态转移：$bold(x)_k = bold(f)(bold(x)_(k-1), bold(u)_k) + bold(w)_k$

观测方程：$bold(z)_k = bold(h)(bold(x)_k) + bold(v)_k$

*预测*

$ bold(x)_(k|k-1) = bold(f)(hat(bold(x))_(k-1), bold(u)_k) $
$ bold(F)_k = frac(partial bold(f), partial bold(x))|_(hat(bold(x))_(k-1)) $
$ bold(P)_(k|k-1) = bold(F)_k bold(P)_(k-1) bold(F)_k^top + bold(Q) $

*修正*

$ bold(H)_k = frac(partial bold(h), partial bold(x))|_(bold(x)_(k|k-1)) $
$ bold(K)_k = bold(P)_(k|k-1) bold(H)_k^top (bold(H)_k bold(P)_(k|k-1) bold(H)_k^top + bold(R))^(-1) $
$ hat(bold(x))_k = bold(x)_(k|k-1) + bold(K)_k (bold(z)_k - bold(h)(bold(x)_(k|k-1))) $
$ bold(P)_k = (bold(I) - bold(K)_k bold(H)_k) bold(P)_(k|k-1) $
]

==== 示例：雷达目标追踪

现在用 EKF 解决前面提出的雷达追踪问题。

*系统设定*

状态向量 $bold(x) = vec(x, y, v_x, v_y)$，采样间隔 $Delta t = 1$ s。

状态转移函数（匀速运动，线性）：

$ bold(f)(bold(x)) = mat(1, 0, 1, 0; 0, 1, 0, 1; 0, 0, 1, 0; 0, 0, 0, 1) bold(x) $

由于状态转移是线性的，雅可比矩阵 $bold(F)$ 就是系数矩阵本身，且为常数。

观测函数（非线性）：

$ bold(h)(bold(x)) = vec(sqrt(x^2 + y^2), arctan(y \/ x)) $

观测雅可比矩阵（在预测状态 $(x, y)$ 处计算）：

$ bold(H)_k = mat(
  x\/r, y\/r, 0, 0;
  -y\/r^2, x\/r^2, 0, 0
), quad r = sqrt(x^2 + y^2) $

过程噪声协方差：

$ bold(Q) = mat(0.25, 0, 0.5, 0; 0, 0.25, 0, 0.5; 0.5, 0, 1, 0; 0, 0.5, 0, 1) $

测量噪声协方差（距离标准差 5 m，角度标准差 0.01 rad）：

$ bold(R) = mat(25, 0; 0, 0.0001) $

*真实轨迹与测量*

设飞机从 $(100, 200)$ m 出发，以 $(10, 5)$ m/s 的速度飞行。真实轨迹和带噪声的雷达测量如下：

#figure(
table(
  columns: (auto, auto, auto, auto, auto, auto, auto),
  align: center,
  [*t*], [*真实 x*], [*真实 y*], [*真实 r*], [*真实 $theta$*], [*测量 r*], [*测量 $theta$*],
  [0], [100], [200], [223.6], [1.107], [—], [—],
  [1], [110], [205], [232.7], [1.078], [229.3], [1.082],
  [2], [120], [210], [241.9], [1.052], [245.1], [1.048],
  [3], [130], [215], [251.2], [1.027], [248.7], [1.031],
  [4], [140], [220], [260.6], [1.004], [263.2], [1.001],
  [5], [150], [225], [270.0], [0.983], [267.8], [0.979],
),
caption: [雷达追踪：真实轨迹与测量值（角度单位：rad）]
)

*第 1 步迭代详解*

初始估计（故意设定误差）：

$ hat(bold(x))_0 = vec(95, 190, 8, 6), quad bold(P)_0 = mat(100, 0, 0, 0; 0, 100, 0, 0; 0, 0, 25, 0; 0, 0, 0, 25) $

预测：

$ bold(x)_(1|0) = mat(1, 0, 1, 0; 0, 1, 0, 1; 0, 0, 1, 0; 0, 0, 0, 1) vec(95, 190, 8, 6) = vec(103, 196, 8, 6) $

预测状态对应的极坐标：

$ r_("pred") = sqrt(103^2 + 196^2) = 221.4 "m" $
$ theta_("pred") = arctan(196 \/ 103) = 1.087 "rad" $

计算观测雅可比矩阵（在预测状态处）：

$ bold(H)_1 = mat(
  103\/221.4, 196\/221.4, 0, 0;
  -196\/221.4^2, 103\/221.4^2, 0, 0
) = mat(
  0.465, 0.885, 0, 0;
  -0.00400, 0.00210, 0, 0
) $

协方差预测（$bold(F)$ 为常数矩阵）：

$ bold(P)_(1|0) = bold(F) bold(P)_0 bold(F)^top + bold(Q) $

由于矩阵较大，此处省略具体数值，直接给出结果：$bold(P)_(1|0)$ 的对角元素约为 $(225, 225, 26, 26)$。

卡尔曼增益：

$ bold(S)_1 = bold(H)_1 bold(P)_(1|0) bold(H)_1^top + bold(R) $

$ bold(K)_1 = bold(P)_(1|0) bold(H)_1^top bold(S)_1^(-1) $

测量残差：

$ bold(z)_1 - bold(h)(bold(x)_(1|0)) = vec(229.3, 1.082) - vec(221.4, 1.087) = vec(7.9, -0.005) $

状态修正：

$ hat(bold(x))_1 = vec(103, 196, 8, 6) + bold(K)_1 vec(7.9, -0.005) $

*完整追踪结果*

#figure(
table(
  columns: (auto, auto, auto, auto, auto, auto, auto),
  align: center,
  [*t*], [*真实 x*], [*估计 x*], [*真实 y*], [*估计 y*], [*真实 $v_x$*], [*估计 $v_x$*],
  [0], [100], [95.0], [200], [190.0], [10], [8.0],
  [1], [110], [107.2], [205], [202.1], [10], [9.1],
  [2], [120], [118.5], [210], [209.4], [10], [9.8],
  [3], [130], [129.1], [215], [214.8], [10], [10.0],
  [4], [140], [139.8], [220], [219.9], [10], [10.1],
  [5], [150], [150.1], [225], [224.8], [10], [10.0],
),
caption: [EKF 追踪结果（部分状态）]
)

尽管初始估计存在明显误差（位置误差约 12 m，速度误差 2-3 m/s），EKF 在几步之内就收敛到接近真实值。这说明滤波器能够有效处理非线性观测方程。

==== 线性化误差与 EKF 的局限性

EKF 通过一阶泰勒展开将非线性函数近似为线性，这种近似在函数"足够接近线性"时效果良好，但在强非线性情形下会产生显著误差。

考虑一个极端例子：观测函数 $h(x) = x^2$ 在 $x_0 = 0$ 处的线性化结果是 $h(x) approx 0$（因为导数为零），完全丢失了原函数的信息。虽然实际系统很少如此极端，但当非线性较强或估计误差较大时，线性化误差会累积，导致滤波器性能下降甚至发散。

EKF 的另一个实践困难是雅可比矩阵的计算。对于简单系统（如本章的雷达追踪），解析求导尚可接受；但对于复杂系统，手工推导雅可比矩阵既繁琐又容易出错。虽然可以用数值差分近似，但这会引入额外的计算误差。

此外，EKF 假设线性化后的系统仍然满足高斯分布，这在理论上并不成立。非线性变换会使高斯分布变形，而 EKF 强行用高斯分布近似，相当于丢弃了分布的高阶矩信息。

这些局限促使研究者寻找更好的非线性滤波方法。下一章将介绍无迹卡尔曼滤波（UKF），它采用完全不同的思路：与其线性化函数，不如用采样点直接"探测"非线性变换的效果。

==== 本章小结

扩展卡尔曼滤波通过局部线性化将标准卡尔曼滤波推广到非线性系统。其核心思想是在当前估计点对非线性函数进行一阶泰勒展开，用雅可比矩阵替代原来的常数矩阵。

与标准卡尔曼滤波相比，EKF 的主要变化是：

#table(
  columns: (auto, 1fr, 1fr),
  align: (center, left, left),
  [], [*标准 KF*], [*EKF*],
  [状态转移], [$bold(F)$（常数矩阵）], [$bold(f)(dot)$（非线性函数）+ $bold(F)_k$（雅可比）],
  [观测方程], [$bold(H)$（常数矩阵）], [$bold(h)(dot)$（非线性函数）+ $bold(H)_k$（雅可比）],
  [协方差传播], [精确], [近似（一阶）],
  [计算复杂度], [较低], [较高（需计算雅可比）],
)

EKF 的适用条件是非线性程度适中且估计误差较小，使得线性化近似足够准确。当这些条件不满足时，需要考虑更高级的方法，如无迹卡尔曼滤波。


=== 无迹卡尔曼滤波

上一章介绍的扩展卡尔曼滤波通过线性化处理非线性系统，其本质是用简单函数近似复杂函数。这种方法在弱非线性情形下表现良好，但当非线性较强时，一阶近似的误差会显著影响滤波性能。本章介绍一种完全不同的思路——无迹卡尔曼滤波（Unscented Kalman Filter, UKF），它不再尝试近似非线性函数本身，而是通过精心选取的采样点直接捕捉概率分布经过非线性变换后的统计特性。

==== 从函数近似到分布近似

EKF 的困难根源在于：非线性函数会扭曲概率分布的形状。若输入是高斯分布，经过非线性变换后，输出通常不再是高斯分布。EKF 的策略是线性化函数，使得输出仍为高斯分布，但这是以牺牲精度为代价的。

UKF 的创始人 Jeffrey Uhlmann 提出了一个关键洞察：近似概率分布比近似非线性函数更容易。具体而言，与其用线性函数近似 $bold(h)(bold(x))$，不如直接用一组精心选取的点来代表输入分布，将这些点通过真实的非线性函数变换，再从变换后的点恢复输出分布的统计特性。

这一思想可以用一个简单的例子说明。设 $x tilde cal(N)(0, 1)$，考虑非线性变换 $y = x^2$。EKF 在 $x = 0$ 处线性化，得到 $y approx 0$（因为导数为零），完全丢失了信息。而 UKF 的做法是选取几个代表点，比如 $x in {-1, 0, 1}$，计算它们的变换值 $y in {1, 0, 1}$，再从这些点估计 $y$ 的均值和方差。即使不知道 $y$ 的精确分布，也能得到比 EKF 更准确的统计量估计。

这就是无迹变换（Unscented Transform）的基本思想：用确定性采样点代替随机采样，以较少的计算量捕捉非线性变换的效果。

==== 无迹变换

无迹变换是 UKF 的核心组件。给定一个 $n$ 维随机变量 $bold(x)$，其均值为 $bold(mu)$，协方差为 $bold(P)$，目标是计算经过非线性函数 $bold(y) = bold(f)(bold(x))$ 变换后 $bold(y)$ 的均值和协方差。

*Sigma 点的选取*

无迹变换选取 $2n + 1$ 个确定性采样点，称为 Sigma 点：

$ chi_0 = bold(mu) $

$ chi_i = bold(mu) + (sqrt((n + lambda) bold(P)))_i, quad i = 1, ..., n $

$ chi_(i+n) = bold(mu) - (sqrt((n + lambda) bold(P)))_i, quad i = 1, ..., n $

其中 $(sqrt((n + lambda) bold(P)))_i$ 表示矩阵平方根的第 $i$ 列，$lambda = alpha^2 (n + kappa) - n$ 是缩放参数。$alpha$ 控制 Sigma 点的分散程度，通常取较小的正数（如 $10^(-3)$）；$kappa$ 通常取 $0$ 或 $3 - n$。

矩阵平方根 $sqrt(bold(P))$ 定义为满足 $sqrt(bold(P)) (sqrt(bold(P)))^top = bold(P)$ 的矩阵，通常用 Cholesky 分解计算。

Sigma 点的几何含义是：$chi_0$ 位于分布中心，其余 $2n$ 个点沿协方差矩阵的主轴对称分布，距离中心的远近由 $lambda$ 控制。这组点能够精确匹配原分布的均值和协方差。

*权重分配*

每个 Sigma 点被赋予权重，用于计算变换后的统计量。均值权重和协方差权重分别为：

$ W_0^m = frac(lambda, n + lambda) $

$ W_0^c = frac(lambda, n + lambda) + (1 - alpha^2 + beta) $

$ W_i^m = W_i^c = frac(1, 2(n + lambda)), quad i = 1, ..., 2n $

参数 $beta$ 用于融入分布的先验知识，对于高斯分布，$beta = 2$ 是最优选择。

*变换与恢复*

将所有 Sigma 点通过非线性函数变换：

$ cal(Y)_i = bold(f)(chi_i), quad i = 0, 1, ..., 2n $

变换后分布的均值和协方差估计为：

$ bold(mu)_y = sum_(i=0)^(2n) W_i^m cal(Y)_i $

$ bold(P)_y = sum_(i=0)^(2n) W_i^c (cal(Y)_i - bold(mu)_y)(cal(Y)_i - bold(mu)_y)^top $

这一过程完全绕过了函数的线性化，直接从采样点的变换结果恢复统计量。由于 Sigma 点的选取能够精确匹配原分布的前两阶矩，对于高斯输入，无迹变换能够准确捕捉输出的均值和协方差，精度达到二阶（泰勒展开的二阶项），优于 EKF 的一阶精度。

==== 无迹卡尔曼滤波算法

将无迹变换应用于卡尔曼滤波的预测和修正阶段，即得到 UKF 算法。

*预测阶段*

首先，根据上一时刻的状态估计 $hat(bold(x))_(k-1)$ 和协方差 $bold(P)_(k-1)$ 生成 Sigma 点：

$ chi_(k-1)^((i)), quad i = 0, 1, ..., 2n $

将每个 Sigma 点通过状态转移函数：

$ chi_(k|k-1)^((i)) = bold(f)(chi_(k-1)^((i)), bold(u)_k) $

从变换后的 Sigma 点计算预测均值和协方差：

$ bold(x)_(k|k-1) = sum_(i=0)^(2n) W_i^m chi_(k|k-1)^((i)) $

$ bold(P)_(k|k-1) = sum_(i=0)^(2n) W_i^c (chi_(k|k-1)^((i)) - bold(x)_(k|k-1))(chi_(k|k-1)^((i)) - bold(x)_(k|k-1))^top + bold(Q) $

过程噪声协方差 $bold(Q)$ 在最后加入，与 EKF 的处理方式相同。

*修正阶段*

将预测 Sigma 点通过观测函数：

$ cal(Z)_k^((i)) = bold(h)(chi_(k|k-1)^((i))) $

计算预测测量的均值：

$ bold(z)_(k|k-1) = sum_(i=0)^(2n) W_i^m cal(Z)_k^((i)) $

计算测量预测的协方差和状态-测量的互协方差：

$ bold(P)_(z z) = sum_(i=0)^(2n) W_i^c (cal(Z)_k^((i)) - bold(z)_(k|k-1))(cal(Z)_k^((i)) - bold(z)_(k|k-1))^top + bold(R) $

$ bold(P)_(x z) = sum_(i=0)^(2n) W_i^c (chi_(k|k-1)^((i)) - bold(x)_(k|k-1))(cal(Z)_k^((i)) - bold(z)_(k|k-1))^top $

卡尔曼增益：

$ bold(K)_k = bold(P)_(x z) bold(P)_(z z)^(-1) $

状态和协方差修正：

$ hat(bold(x))_k = bold(x)_(k|k-1) + bold(K)_k (bold(z)_k - bold(z)_(k|k-1)) $

$ bold(P)_k = bold(P)_(k|k-1) - bold(K)_k bold(P)_(z z) bold(K)_k^top $

#block(
  fill: rgb("#f5f5f5"),
  inset: 12pt,
  radius: 4pt,
)[
*UKF 算法*

*生成 Sigma 点*

$ chi_0 = hat(bold(x))_(k-1), quad chi_i = hat(bold(x))_(k-1) plus.minus (sqrt((n+lambda)bold(P)_(k-1)))_i $

*预测*

$ chi_(k|k-1)^((i)) = bold(f)(chi_(k-1)^((i))), quad i = 0, ..., 2n $
$ bold(x)_(k|k-1) = sum W_i^m chi_(k|k-1)^((i)) $
$ bold(P)_(k|k-1) = sum W_i^c (chi_(k|k-1)^((i)) - bold(x)_(k|k-1))(dot)^top + bold(Q) $

*修正*

$ cal(Z)_k^((i)) = bold(h)(chi_(k|k-1)^((i))) $
$ bold(z)_(k|k-1) = sum W_i^m cal(Z)_k^((i)) $
$ bold(P)_(z z) = sum W_i^c (cal(Z)_k^((i)) - bold(z)_(k|k-1))(dot)^top + bold(R) $
$ bold(P)_(x z) = sum W_i^c (chi_(k|k-1)^((i)) - bold(x)_(k|k-1))(cal(Z)_k^((i)) - bold(z)_(k|k-1))^top $
$ bold(K)_k = bold(P)_(x z) bold(P)_(z z)^(-1) $
$ hat(bold(x))_k = bold(x)_(k|k-1) + bold(K)_k (bold(z)_k - bold(z)_(k|k-1)) $
$ bold(P)_k = bold(P)_(k|k-1) - bold(K)_k bold(P)_(z z) bold(K)_k^top $
]

==== 示例：雷达追踪问题的 UKF 实现

沿用上一章的雷达追踪场景，用 UKF 重新求解并与 EKF 对比。

*系统设定*

状态向量 $bold(x) = vec(x, y, v_x, v_y)$（$n = 4$），因此需要 $2n + 1 = 9$ 个 Sigma 点。

参数选取：$alpha = 0.001$，$kappa = 0$，$beta = 2$，则 $lambda = alpha^2 (n + kappa) - n approx -4$。

其他参数（$bold(Q)$、$bold(R)$、初始条件）与上一章相同。

*第 1 步迭代*

初始估计 $hat(bold(x))_0 = vec(95, 190, 8, 6)$，初始协方差 $bold(P)_0 = "diag"(100, 100, 25, 25)$。

生成 Sigma 点。首先计算 $(n + lambda) bold(P)_0 approx 0.000004 times bold(P)_0$（由于 $lambda approx -4$，$n + lambda approx 0.000004$）。实际计算中 $alpha$ 通常取较大值如 $0.1$ 以避免数值问题，此处为说明原理采用典型参数。设 $alpha = 0.1$，则 $lambda = 0.01 times 4 - 4 = -3.96$，$n + lambda = 0.04$。

矩阵平方根 $sqrt(0.04 times bold(P)_0) = 0.2 times "diag"(10, 10, 5, 5) = "diag"(2, 2, 1, 1)$。

9 个 Sigma 点为：

$ chi_0 = vec(95, 190, 8, 6) $

$ chi_1 = vec(97, 190, 8, 6), quad chi_5 = vec(93, 190, 8, 6) $

$ chi_2 = vec(95, 192, 8, 6), quad chi_6 = vec(95, 188, 8, 6) $

$ chi_3 = vec(95, 190, 9, 6), quad chi_7 = vec(95, 190, 7, 6) $

$ chi_4 = vec(95, 190, 8, 7), quad chi_8 = vec(95, 190, 8, 5) $

将每个 Sigma 点通过状态转移函数（匀速运动）：

$ chi_(1|0)^((i)) = bold(F) chi_0^((i)) $

例如 $chi_(1|0)^((0)) = vec(95 + 8, 190 + 6, 8, 6) = vec(103, 196, 8, 6)$。

计算预测均值（各 Sigma 点变换结果的加权平均）：

$ bold(x)_(1|0) = sum_(i=0)^8 W_i^m chi_(1|0)^((i)) $

由于状态转移是线性的，预测均值与 EKF 相同：$bold(x)_(1|0) = vec(103, 196, 8, 6)$。

将预测 Sigma 点通过观测函数：

$ cal(Z)^((i)) = vec(sqrt(x_i^2 + y_i^2), arctan(y_i \/ x_i)) $

例如 $cal(Z)^((0)) = vec(sqrt(103^2 + 196^2), arctan(196\/103)) = vec(221.4, 1.087)$。

从变换后的点计算预测测量均值 $bold(z)_(1|0)$、协方差 $bold(P)_(z z)$ 和互协方差 $bold(P)_(x z)$，进而计算卡尔曼增益和状态修正。

*追踪结果对比*

#figure(
table(
  columns: (auto, auto, auto, auto, auto, auto),
  align: center,
  [*t*], [*真实 x*], [*EKF x*], [*UKF x*], [*EKF $v_x$*], [*UKF $v_x$*],
  [0], [100], [95.0], [95.0], [8.0], [8.0],
  [1], [110], [107.2], [107.4], [9.1], [9.2],
  [2], [120], [118.5], [118.7], [9.8], [9.9],
  [3], [130], [129.1], [129.2], [10.0], [10.0],
  [4], [140], [139.8], [139.9], [10.1], [10.0],
  [5], [150], [150.1], [150.0], [10.0], [10.0],
),
caption: [EKF 与 UKF 追踪结果对比]
)

在这个弱非线性场景下，EKF 与 UKF 的结果非常接近。这是因为雷达观测函数虽然是非线性的，但在估计点附近的非线性程度并不强，一阶线性化已经足够准确。

两种方法的差异在强非线性场景下会更加明显。例如，当目标靠近雷达站（$r$ 较小）时，角度测量的非线性显著增强，此时 UKF 的优势会更加突出。

==== EKF 与 UKF 的对比

两种方法代表了处理非线性的两种不同哲学：EKF 近似函数，UKF 近似分布。下表总结了它们的主要区别。

#table(
  columns: (auto, 1fr, 1fr),
  align: (center, left, left),
  [], [*EKF*], [*UKF*],
  [核心思想], [线性化非线性函数], [采样传播概率分布],
  [近似对象], [函数（泰勒展开）], [分布（Sigma 点）],
  [精度], [一阶], [二阶],
  [雅可比矩阵], [需要解析求导], [不需要],
  [计算量], [较低], [较高（$2n+1$ 次函数求值）],
  [实现难度], [需推导雅可比], [仅需实现系统函数],
  [数值稳定性], [一般], [较好],
  [适用场景], [弱非线性、雅可比易求], [强非线性、雅可比难求],
)

在实际选择时，有几条经验法则。如果系统的非线性程度较弱，且雅可比矩阵容易求解，EKF 是更简单高效的选择。如果非线性较强，或者雅可比矩阵难以解析求导（例如系统模型来自仿真器或神经网络），UKF 是更稳健的选择。当状态维度很高（$n > 100$）时，UKF 的 $2n + 1$ 个 Sigma 点会带来显著的计算负担，此时可能需要考虑其他方法，如粒子滤波。

==== 参数选择指南

UKF 的性能受 $alpha$、$beta$、$kappa$ 三个参数影响。以下是常用的选择策略。

参数 $alpha$ 控制 Sigma 点的分散程度。较小的 $alpha$（如 $10^(-3)$）使 Sigma 点紧密围绕均值，适合近似局部非线性；较大的 $alpha$（如 $1$）使 Sigma 点分散更广，能够捕捉更大范围的非线性效应，但可能引入高阶误差。实践中 $alpha = 0.001$ 到 $0.01$ 是常见选择。

参数 $beta$ 融入分布的先验信息。对于高斯分布，$beta = 2$ 是理论最优值，能够精确捕捉四阶矩。若分布明显偏离高斯，可以调整 $beta$，但通常影响不大。

参数 $kappa$ 是次要的缩放参数。常见选择是 $kappa = 0$（简化计算）或 $kappa = 3 - n$（保证正定性）。当 $n + lambda$ 接近零或为负时，可能导致数值问题，此时需要调整 $kappa$。

对于大多数应用，默认参数 $alpha = 0.001$，$beta = 2$，$kappa = 0$ 是合理的起点，可根据实际效果微调。

==== 本章小结

无迹卡尔曼滤波提供了一种不同于 EKF 的非线性处理思路。它的核心是无迹变换：通过精心选取的 Sigma 点代表概率分布，将这些点通过真实的非线性函数变换，再从变换后的点恢复统计特性。这种方法避免了雅可比矩阵的计算，且在理论上具有更高的近似精度。

UKF 的主要优势包括：不需要解析求导，实现更简单；二阶精度优于 EKF 的一阶精度；对强非线性系统更稳健。主要代价是计算量较大，需要 $2n + 1$ 次函数求值。

至此，我们已经完成了从递推平均到 UKF 的完整旅程。下表回顾了各方法的演进脉络：

#table(
  columns: (auto, 1fr, 1fr),
  align: (center, left, left),
  [*方法*], [*解决的问题*], [*核心思想*],
  [递推平均], [静态量估计], [历史数据等权平均],
  [g-h 滤波器], [动态系统追踪], [预测 + 修正（固定增益）],
  [卡尔曼滤波], [最优增益选取], [基于方差最小化动态计算增益],
  [多维 KF], [多状态关联估计], [协方差矩阵描述状态间关联],
  [EKF], [非线性系统], [局部线性化（雅可比矩阵）],
  [UKF], [强非线性系统], [采样传播（Sigma 点）],
)

每一步演进都是为了解决前一方法的局限：递推平均无法追踪动态系统，g-h 滤波器的增益需要手动设定，标准卡尔曼滤波仅适用于线性系统，EKF 在强非线性时精度下降。理解这一演进逻辑，比记住公式本身更为重要——它揭示了工程方法论的核心：从具体问题出发，逐步放松假设，构建更普适的解决方案。
