#import "/template/template.typ": *
#definition()[
#set list(indent: 2em)
#{
  set par(first-line-indent: 0pt)
  [本章使用的符号规定：]
}

- *粗体小写字母* 表示向量，例如 $bold(x)$
- *粗体大写字母* 表示矩阵，例如 $bold(A)$
- *普通小写字母* 标量或向量的分量
- *普通大写字母* 表示矩阵元素
]
=== 什么是卡尔曼滤波？


=== 状态空间方程
状态空间方程是现代控制理论的基础，它以矩阵的形式表达系统的状态变量，输入及输出的关系。它可以描述和处理多输入多输出的系统。

=== 如何准确地测量体重
假设存在一个测量精度有限的体重秤。在实际测量过程中,该设备会产生随机误差,导致单次测量结果与真实体重之间存在偏差。为提高测量精度，可以通过多次采样与数据处理的方法获得更稳定的估计值。

首先，对同一对象进行 $n$ 次测量，每次记录体重秤的显示值。由于体重秤的误差通常呈随机分布，重复测量可以在一定程度上抵消单次测量的偏差。随后，将全部测量值求平均，得到较为稳定的估计值：

$ hat(x)_n = frac(1, n)(z_1 + z_2 + ... + z_n)= frac(1, n)sum_(i=1)^n z_i $

上述操作虽然在数学层面较为直观，但在工程应用中存在实现困难。根据平均值的定义，为了计算 $hat(x)_n$，需要存储所有历史测量值 $z_1, z_2, …, z_n$。当 $n$ 较大时，会产生显著的内存开销，对嵌入式设备而言尤为不利。此外，每次获得新的测量值后都需要重新遍历全部历史数据进行计算，其时间复杂度为 $O(n)$，会对处理器造成不必要的负担。

因此，需要寻找一种递推（Recursive）形式，使得算法满足以下特性：无需保存全部历史数据，无需重复计算，仅依赖上一次估计 $hat(x)_(n-1)$ 和当前测量 $z_n$

为实现上述目标，可将平均值公式改写为状态更新方程。通过代数变换，得到以下递推形式：

$
hat(x)_n = hat(x)_(n-1) + 1/n (z_n - hat(x)_(n-1))
$

该表达式揭示了递推估计的核心机制：第 $n$ 时刻的状态估计 $hat(x)_n$ 由两部分构成——前一时刻的估计值 $hat(x)_(n-1)$ 以及基于当前测量值 $z_n$ 的修正项 $(z_n - hat(x)_(n-1))$。因此,算法无需保存全部历史数据,仅需利用上一时刻的估计结果即可完成当前状态的更新,显著降低了计算复杂度（降至 $O(1)$）与存储需求。

#note("详细推导")[
$
hat(x)_n &= 1/n sum_(i=1)^n z_i 
= 1/n (sum_(i=1)^(n-1) z_i + z_n) \
&= 1/n sum_(i=1)^(n-1) z_i + 1/n z_n 
= (n-1)/(n(n-1)) sum_(i=1)^(n-1) z_i + 1/n z_n \
&= (n-1)/n dot 1/(n-1) sum_(i=1)^(n-1) z_i + 1/n z_n 
= (n-1)/n hat(x)_(n-1) + 1/n z_n \
&= hat(x)_(n-1) - 1/n hat(x)_(n-1) + 1/n z_n \
&= hat(x)_(n-1) + 1/n (z_n - hat(x)_(n-1))
$

#table(
  columns: (auto, 1fr),
  align: (center, left),
  stroke: (x, y) => (
    top: if y == 1 or y == 0 { 1pt } else { 0pt },
    bottom: if y == 5 { 1pt } else { 0pt },
  ),
  inset: 8pt,
  
  [*符号*], [*含义*],
  
  [$x$], 
  [体重的真值],
  
  [$z_n$], 
  [第 $n$ 次对体重的测量值],
  
  [$hat(x)_n$], 
  [基于前 $n$ 次测量值,对 $x$ 的估计值],
  
  [$hat(x)_(n-1)$], 
  [基于前 $n-1$ 次测量值,对 $x$ 的估计值],
  
  [$z_n - hat(x)_(n-1)$], 
  [测量残差：当前测量值与先验估计之间的偏差],
)
]

至此，上述平均值递推公式已经可以被视为一种特殊形式的状态估计滤波器。其中，增益系数

$
K_n = 1/n
$

决定了"当前观测"与"历史估计"在融合时各自的权重。该系数随测量次数增加而递减，表明随着可用数据增多，单次新测量对整体估计的影响逐渐减小。本例中，随着$n$的增加，$1/n$会下降。在一开始，因为没有足够的信息，第一次估计完全是基于第一次的测量值的$1/n|_(n=1)=1$. 随着迭代进行，每次后续测量的权重都在下降，并且会逐渐变得可以忽略不计。这一结构与卡尔曼滤波的状态更新公式在形式上完全一致：

$
hat(x)_k = hat(x)_(k|k-1) + K_k (z_k - h(hat(x)_(k|k-1)))
$

其中：
$hat(x)_(k|k-1)$ 为基于前 $k-1$ 次观测对第 $k$ 时刻的预测值（先验估计）$z_k$ 为第 $k$ 次测量值$h(dot)$ 为观测函数，将状态映射到观测空间$K_k$ 为卡尔曼增益，动态调节预测值与测量值的融合比例

在体重秤的简化场景中，系统状态不随时间变化（$hat(x)_(k|k-1) = hat(x)_(k-1)$），且观测函数为恒等映射（$h(x) = x$），因此递推平均公式可视为卡尔曼滤波在静态系统、确定性观测条件下的特例。


将上述公式重新标注为：

$
hat(x)_n = underbrace(hat(x)_(n-1), "先验估计") + underbrace(1/n, "增益系数") underbrace((z_n - hat(x)_(n-1)), "测量残差")
$

这一形式揭示了三个关键组成部分：

*先验估计（Prior Estimate）*

$hat(x)_(n-1)$ 代表在获得第 $n$ 次测量之前，系统对状态的当前认知。对于静态系统（状态不随时间变化），先验估计即为上一时刻的后验估计。该项体现了系统对历史信息的继承。

*测量残差（Measurement Residual）*

$r_n = z_n - hat(x)_(n-1)$ 反映了观测值与先验估计之间的偏差。若测量值高于估计值，则 $r_n > 0$；反之则 $r_n < 0$。测量残差是滤波器进行状态修正的驱动信号。

*增益系数（Gain Coefficient）*

$K_n = 1/n$ 决定了测量残差在状态更新中所占的权重，是滤波器设计中的核心参数。

上述"先验估计 + 增益 × 残差"的结构，正是所有递推估计算法的通用框架。

=== 从体重秤到赛车：静态估计的局限性
在第 1 章中，我们成功地用递推平均估计了体重：


$
hat(x)_n = hat(x)_(n-1) + 1/n (z_n - hat(x)_(n-1))
$

之所以该方法能够有效，是因为体重这一物理量在测量过程中近似静止不变，因此所有测量偏差都可以视为传感器噪声，重复测量并求平均即可逐渐逼近真实值。

然而，当我们将同样的方法应用于一个动态系统时，情况就会发生改变。现在考虑一个新场景：追踪赛道上的赛车。

*假设：*这个赛车起始位置位于 0 米，并以 20 米/秒的恒定速度行驶。GPS 每秒测量一次位置，但有 ±5 米的随机误差

因此，按照按照物理规律，赛车的真实轨迹为：
$p_t=20 dot t$ 其中$t$为秒数

但 GPS 的测量值满足：
$z_t=p_t+"噪声"$

#figure(
table(
columns: (auto, auto, auto, auto, auto),
align: (center, center, center, center, center),
[*时刻*\ (秒)], 
[*真实位置*\ (米)], 
[*GPS 测量*\ (米)], 
[*递推平均*\ (米)], 
[*估计误差*\ (米)],

[0], [0], [1.2], [1.2], [+1.2],
[1], [20], [18.3], [9.8], [−10.2],
[2], [40], [43.1], [20.9], [−19.1],
[3], [60], [56.8], [29.9], [−30.1],
[4], [80], [82.4], [40.4], [−39.6],
[5], [100], [97.6], [49.9], [−50.1],
),
caption: [递推平均追踪赛车的实验数据]
)

如表所示，估计值严重落后，且差距不断扩大。究其原因，递推平均的公式结构：

$
hat(x)_n = underbrace(hat(x)_(n-1), "上次估计") + underbrace(frac(1, n) (z_n - hat(x)_(n-1)), "基于测量的修正")
$

其本质问题在于：该公式*只有修正，没有预测*。随着测量次数 $n$ 增加，增益系数 $1/n$ 不断减小，新测量对估计值的影响逐渐微弱。该公式假设被估计的量保持不变，因此所有测量偏差都被视为需要消除的噪声。但对于运动的赛车，测量值的变化不仅包含噪声，更反映了*真实的位置变化*。递推平均无法区分这两者，只是机械地对所有历史数据求平均，导致估计值始终"追不上"真实位置。

正确的思路应该是：在获得新测量之前，先根据赛车的运动规律*主动预测*它现在应该在哪里，然后再用测量值进行修正。这就是 g-h 滤波器的核心思想。

==== g-h 滤波器

对于运动物体，估计公式应该包含*预测*步骤：

#align(center)[
  #block(
    fill: rgb("#e3f2fd"),
    inset: 15pt,
    radius: 6pt,
    stroke: 1.5pt + rgb("#2196f3")
  )[
    估计 = #text(fill: blue)[*预测*]（基于运动模型）+ 修正（基于测量）
  ]
]

===== 预测步骤：利用运动模型

假设在第 $k-1$ 时刻已经得到了位置与速度的估计值：
- 位置：$hat(p)_(k-1)$
- 速度：$hat(v)_(k-1)$

根据匀速运动模型，可以预测第 $k$ 时刻的位置：

$ p_("pred",k) = hat(p)_(k-1) + hat(v)_(k-1) * Delta t $

其中 $Delta t$ 为时间间隔（本例为 1 秒）。

速度在匀速假设下保持不变：

$ v_("pred",k) = hat(v)_(k-1) $

这是最基本的直线匀速运动模型。

*示例：*
若 $hat(p)_0 = 0$ 米，$hat(v)_0 = 15$ 米/秒，则

$ p_("pred",1) = 0 + 15 * 1 = 15 "米" $


===== 修正步骤：融合测量信息

当 GPS 测量值 $z_k$ 到来时，可以计算预测与测量之间的残差（Residual）：

$ r_k = z_k - p_("pred",k) $

示例：若 $z_1 = 18.3$ 米，

$ r_1 = 18.3 - 15 = 3.3 "米" $


====== 位置修正

预测与测量的加权融合如下：

$ hat(p)_k = p_("pred",k) + g * r_k $

其中 $g$ 为位置增益，满足 $0 < g < 1$。

*物理意义：*
- $g = 0$: 完全信任预测  
- $g = 1$: 完全信任测量  
- $g = 0.3$: 预测 70%，测量 30%

示例（$g = 0.3$）：

$ hat(p)_1 = 15 + 0.3 * 3.3 = 15.99 "米" $


====== 速度修正（g-h 滤波器的核心）

位置残差反映运动趋势误差，因此也用于修正速度：

$ hat(v)_k = v_("pred",k) + (h / Delta t) * r_k $

其中 $h$ 为速度增益，$0 < h < 1$。

#note("为什么要除以 $Delta t$？")[
残差 $r_k$ 的单位是米，为了将“位置误差”转成“速度误差”，需要除以时间间隔：

$("米") / ("秒") = "米/秒"$

含义：  
“若位置误差为 $r_k$ 米，那速度应增加多少才能在 $Delta t$ 秒内弥补这一误差？”
]

示例（$h = 0.1$, $Delta t = 1$ 秒）：

$ hat(v)_1 = 15 + 0.1 * 3.3 = 15.33 "米/秒" $

#block(
  fill: rgb("#e8f5e9"),
  inset: 10pt,
  radius: 4pt,
)[
  *观察：*

  - 残差为正 → 预测位置偏低  
  - 速度被上调（15 → 15.33 米/秒）  
  - 若赛车走得比预期远，则它速度更快
]


===== g-h 滤波器完整算法

#block(
  fill: rgb("#f3e5f5"),
  inset: 12pt,
  radius: 4pt,
  stroke: 1.5pt + rgb("#9c27b0")
)[
  *g-h 滤波器算法*

  *输入：*
  - 上一时刻估计：$hat(p)_(k-1)$, $hat(v)_(k-1)$
  - 当前测量：$z_k$
  - 时间间隔：$Delta t$
  - 增益参数：$g, h$

  *步骤 1：预测*
  $ p_("pred",k) = hat(p)_(k-1) + hat(v)_(k-1) * Delta t $
  $ v_("pred",k) = hat(v)_(k-1) $

  *步骤 2：计算残差*
  $ r_k = z_k - p_("pred",k) $

  *步骤 3：修正*
  $ hat(p)_k = p_("pred",k) + g * r_k $
  $ hat(v)_k = v_("pred",k) + (h / Delta t) * r_k $

  *输出：*
  - $hat(p)_k$, $hat(v)_k$
]


===== 数值示例：追踪赛车

参数设定：
- 真实速度：$20 "米/秒"$
- $Delta t = 1$ 秒
- $g = 0.3$, $h = 0.1$
- 初始估计：$hat(p)_0=0$, $hat(v)_0=15$（故意错误）

====== 第 1 次迭代

测量：$z_1 = 18.3$ 米

预测：
$ p_("pred",1) = 0 + 15 = 15 "米" $
$ v_("pred",1) = 15 $

残差：
$r_1 = 3.3 "米"$

修正：
$ hat(p)_1 = 15 + 0.3 * 3.3 = 15.99 $
$ hat(v)_1 = 15 + 0.1 * 3.3 = 15.33 $

====== 第 2 次迭代

测量：$z_2 = 43.1$ 米

预测：
$ p_("pred",2) = 15.99 + 15.33 = 31.32 $
$ v_("pred",2) = 15.33 $

残差：
$r_2 = 11.78$

修正：
$ hat(p)_2 = 31.32 + 0.3 * 11.78 = 34.85 $
$ hat(v)_2 = 15.33 + 0.1 * 11.78 = 16.51 $


===== 完整追踪过程表格

#figure(
table(
  columns: (auto, auto, auto, auto, auto, auto),
  align: center,
  
  [*时刻* (秒)], 
  [*真实位置* (米)], 
  [*GPS 测量* (米)], 
  [*g-h 估计* (米)], 
  [*真实速度*], 
  [*速度估计*],
  
  [0], [0], [—], [0.0], [20], [15.00],
  [1], [20], [18.3], [16.0], [20], [15.33],
  [2], [40], [43.1], [34.9], [20], [16.51],
  [3], [60], [56.8], [54.3], [20], [17.68],
  [4], [80], [82.4], [74.8], [20], [18.73],
  [5], [100], [97.6], [96.0], [20], [19.60],
),
caption: [g-h 滤波器追踪赛车实验数据]
)

#block(
  fill: rgb("#e8f5e9"),
  inset: 10pt,
  radius: 4pt,
)[
  *关键观察：*
  
  - 位置误差逐步收敛  
  - 速度估计自动逼近真实值  
  - 初始误差可被消除  
  - 完全不同于递推平均的「滞后问题」
]


===== 对比：递推平均 vs g-h 滤波器

#figure(
table(
  columns: (auto, auto, auto, auto),
  align: center,
  
  [*时刻 (秒)*], [*真实位置 (米)*], [*递推平均 (米)*], [*g-h 滤波 (米)*],
  
  [0], [0], [1.2], [0.0],
  [1], [20], [9.8], [16.0],
  [2], [40], [20.9], [34.9],
  [3], [60], [29.9], [54.3],
  [4], [80], [40.4], [74.8],
  [5], [100], [49.9], [96.0],
),
caption: [两种方法在同一数据上的对比]
)

#table(
  columns: (auto, 1fr, 1fr),
  align: (center, left, left),
  
  [], [*递推平均*], [*g-h 滤波器*],
  
  [适用场景], [静态量], [动态系统],
  [预测机制], [✗ 无], [✓ 有（运动模型）],
  [状态数量], [1], [2（位置+速度）],
  [增益系数], [$1/n$（递减）], [$g,h$（固定）],
  [第5秒误差], [50.1 米], [4.0 米],
  [追踪能力], [严重滞后], [成功追踪],
)

在前一章中，通过递推平均的方法实现了对体重的高效估计。该方法基于一个关键假设：*被测量的物理量在整个测量过程中保持不变*。

然而，这一假设并不是在所有应用中都成立。考虑以下场景：

*场景一：体重测量*

当一个人站在体重秤上时，其体重在测量过程中基本保持恒定。即使进行多次测量，真实体重也不会发生显著变化。此时，所有测量误差均来自传感器噪声，递推平均方法能够有效工作。

*场景二：赛车位置追踪*

对于高速行驶的赛车，其位置每秒可能变化数十米甚至上百米。若仍使用递推平均方法，算法会持续"追赶"真实位置，但永远落后于实际状态。当赛车加速、转弯或制动时，这种滞后会更加明显。

*场景三：无人机姿态估计*

无人机在飞行过程中，其姿态角（俯仰、偏航、翻滚）会随操控指令快速变化。若不考虑姿态的动态演化规律，仅依靠传感器测量进行平均，将无法实现稳定的姿态控制。

换言之，对于动态系统而言：*不预测，就不能准确估计。*

==== 从标量估计到状态向量

既然预测是必需的,那么接下来需要回答一个更基本的问题:*预测的对象是什么？*

回到赛车追踪的例子。假设当前时刻赛车位于 100 米处,需要预测 1 秒后它会在哪里。仅凭"当前位置是 100 米"这一信息,能否完成预测？

答案是否定的。因为:
- 若赛车静止不动,1 秒后仍在 100 米处
- 若赛车以 10 m/s 行驶,1 秒后在 110 米处
- 若赛车以 50 m/s 行驶,1 秒后在 150 米处

可见,*仅知道位置无法预测未来位置*。必须同时知道速度,才能推断物体下一时刻会移动到何处。

同样地,仅知道速度也不够。速度告诉我们"每秒移动多少米",但没有当前位置作为起点,同样无法确定未来位置的绝对值。

因此,要预测运动物体的未来状态,必须*同时跟踪位置和速度*。更一般地说,需要跟踪所有对系统未来行为有影响的变量。这些变量的集合,就构成了系统的*状态*。

==== 状态向量：描述系统的完整信息

为描述动态系统的行为，需要定义*状态（State）*。状态是能够完整刻画系统当前特性的变量集合。对于运动物体，仅知道位置是不够的：若不知道速度，就无法预测下一时刻位置会变化多少。

因此，对于一维匀速运动，状态向量定义为：

$
bold(x)_k = vec(p_k, v_k)
$

其中：
- $p_k$ 表示第 $k$ 时刻的位置（Position）
- $v_k$ 表示第 $k$ 时刻的速度（Velocity）

使用状态向量的目的，是为了让系统可以通过统一的矩阵形式组织、推广，并最终引出卡尔曼滤波的结构。

==== 最简单的动态模型：匀速运动

考虑最基本的动态系统——*匀速运动（Constant Velocity Model）*。假设物体在时间间隔 $Delta t$ 内以恒定速度运动，则有：

$
p_k &= p_(k-1) + v_(k-1) Delta t \
v_k &= v_(k-1)
$

第一个方程表明：新位置等于旧位置加上"速度乘以时间"。这是高中物理中的基本运动学公式。

第二个方程表明：速度保持不变。这正是"匀速"的含义。

将上述方程写为矩阵形式：

$
vec(p_k, v_k) = mat(1, Delta t; 0, 1) vec(p_(k-1), v_(k-1))
$

即：

$
bold(x)_k = bold(F) bold(x)_(k-1)
$

其中*状态转移矩阵（State Transition Matrix）*为：

$
bold(F) = mat(1, Delta t; 0, 1)
$

该矩阵编码了系统的动态规律：
- 第一行 $[1, Delta t]$：位置更新公式
- 第二行 $[0, 1]$：速度保持不变

状态转移矩阵 $bold(F)$ 是预测的核心。只要给定当前状态 $bold(x)_(k-1)$，就可以通过 $bold(F)$ 计算下一时刻的状态 $bold(x)_k$。

==== 模型不完美：过程噪声

然而，现实世界中不存在完美的匀速运动。物体可能受到以下影响：
- 轻微的加速度波动
- 外界扰动（风阻、摩擦力、路面颠簸）
- 模型简化带来的误差（例如忽略了加速度项）

为描述这些不确定性，在状态转移方程中加入*过程噪声（Process Noise）*项：

$
bold(x)_k = bold(F) bold(x)_(k-1) + bold(w)_(k-1)
$

其中 $bold(w)_(k-1)$ 表示第 $k-1$ 时刻的过程噪声。该噪声通常假设服从高斯分布：

$
bold(w)_k tilde cal(N)(bold(0), bold(Q))
$

这里的 $bold(Q)$ 称为*过程噪声协方差矩阵*，它刻画了模型不确定性的强度：
- *$bold(Q)$ 较大*：表示系统动态变化剧烈，模型预测不够可靠（例如赛车频繁加减速）
- *$bold(Q)$ 较小*：表示系统演化较为稳定，模型预测较为准确（例如匀速直线行驶）

过程噪声的引入使得模型更加贴近现实。它承认了一个事实：*任何数学模型都无法完美描述真实系统*。

==== 预测与更新：卡尔曼滤波的双重机制

至此，已建立了动态系统的基本描述框架。卡尔曼滤波正是基于这一框架，通过两个交替执行的步骤实现状态估计：

*步骤一：预测（Prediction）*

利用状态转移方程，根据上一时刻的估计值预测当前时刻的状态：

$
hat(bold(x))_(k|k-1) = bold(F) hat(bold(x))_(k-1|k-1)
$

此时尚未获得新的测量数据，预测完全依赖系统的动态模型。

*步骤二：更新（Update）*

当新的测量值 $bold(z)_k$ 到达后，将其与预测值融合，得到更优的状态估计：

$
hat(bold(x))_(k|k) = hat(bold(x))_(k|k-1) + bold(K)_k (bold(z)_k - bold(H) hat(bold(x))_(k|k-1))
$

其中 $bold(H)$ 为*观测矩阵*，用于将状态空间映射到测量空间。例如，当状态包含位置和速度，但传感器只能测量位置时，$bold(H)$ 负责从状态向量中提取出可观测的部分。

这一结构与前一章的递推平均公式完全一致，但增加了预测步骤。*预测使得算法能够主动追踪系统动态，而不是被动地对测量求平均*。

下一章，我们将首先探索如何用简单的 $g$ 和 $h$ 常数来确定增益 $bold(K)_k$ (g-h 滤波器)，它决定了我们究竟该相信模型预测，还是相信传感器测量。为了透彻理解这一核心机制，下一章我们将暂时放下复杂的矩阵运算，通过“g-h 滤波器”这一简化模型，手动调节 $g$ 和 $h$ 两个常数增益。这将帮助我们建立对“滤波”的直观物理认识，并最终引出卡尔曼滤波是如何自动计算出最优增益的。

=== g-h 滤波器：手动调节的预测与修正

在上一章中，我们认识到动态系统估计的核心在于*预测*。仅靠测量求平均无法追踪运动物体，必须利用系统的动态规律主动推断未来状态。

本章将通过 *g-h 滤波器* 这一简化模型，建立对"预测-修正"机制的直观理解。它是卡尔曼滤波的"手动挡"版本，虽然简单，却蕴含了滤波算法的全部精髓。

==== 问题设定：追踪匀速运动的物体

假设需要追踪一辆在直线轨道上行驶的小车。根据上一章建立的框架：

- *状态向量*：
  $ bold(x)_k = vec(p_k, v_k) $
  其中 $p_k$ 为位置，$v_k$ 为速度。

- *动态模型*（匀速运动）：
  $ p_k &= p_(k-1) + v_(k-1) Delta t \
    v_k &= v_(k-1) $

- *传感器测量*：GPS 每隔 $Delta t = 1$ 秒提供一次位置测量 $z_k$，但测量值含有噪声。

核心问题在于：如何融合*模型预测*和*传感器测量*，得到最优的位置和速度估计？

==== 预测步骤：利用动态模型

在第 $k$ 时刻的测量到达之前，先根据上一时刻的估计值进行预测。

#{
  set par(first-line-indent: 0pt)
  [*位置预测*]
}

根据匀速运动模型：
$ p_(p r e d) = hat(p)_(k-1) + hat(v)_(k-1) Delta t $

这里的 $hat(p)_(k-1)$ 和 $hat(v)_(k-1)$ 是第 $k-1$ 时刻的最优估计（后验估计）。

假设上一时刻估计小车位于 100 米，速度为 20 米/秒，时间间隔 $Delta t = 1$ 秒，则预测位置为：
$ p_(p r e d) = 100 + 20 times 1 = 120 " 米" $

#{
  set par(first-line-indent: 0pt)
  [*速度预测*]
}

对于匀速模型，速度保持不变：
$ v_(p r e d) = hat(v)_(k-1) $

此时，在测量到达前，先验估计为：
$ vec(p_(p r e d), v_(p r e d)) = vec(120, 20) $

==== 测量到达：发现预测偏差

现在，GPS 测量值到达：$z_k = 115$ 米。

预测值与测量值之间存在*残差*（Residual）：
$ r_k = z_k - p_(p r e d) = 115 - 120 = -5 " 米" $

负号表示测量值*低于*预测值。这意味着什么？可能存在以下情况：
- 小车实际位置确实在 115 米，预测高估了
- GPS 测量有误差，小车实际就在 120 米附近
- 真实位置介于两者之间（最可能）

滤波器的任务，就是在预测和测量之间找到*合理的平衡点*。

==== 修正步骤：引入 $g$ 和 $h$ 增益

#{
  set par(first-line-indent: 0pt)
  [*修正位置估计：$g$ 增益*]
}

既不能完全信任测量，也不能完全信任预测。合理的做法是取加权平均：
$ hat(p)_k = p_(p r e d) + g dot (z_k - p_(p r e d)) $

其中 $g$ 称为*位置增益*，取值范围通常为 $0 < g < 1$。

*物理意义*：
- $g = 0$：完全信任预测，忽略测量（$hat(p)_k = p_(p r e d)$）
- $g = 1$：完全信任测量，忽略预测（$hat(p)_k = z_k$）
- $g = 0.3$：预测权重 70%，测量权重 30%

*示例*：选择 $g = 0.3$，修正后的位置估计为：
$ hat(p)_k = 120 + 0.3 times (-5) = 120 - 1.5 = 118.5 " 米" $

#{
  set par(first-line-indent: 0pt)
  [*修正速度估计：$h$ 增益*]
}

这是 g-h 滤波器的关键设计：*位置预测出现偏差，往往说明速度估计存在误差*。

考虑以下逻辑链：
#set enum(indent: 2em)
1. 位置残差为 $-5$ 米，说明预测位置偏高
2. 位置偏高，可能是因为*高估了上一时刻的速度*
3. 因此，应该*下调速度估计*

速度修正公式为：
$ hat(v)_k = v_(p r e d) + h / (Delta t) dot (z_k - p_(p r e d)) $

其中 $h$ 称为*速度增益*，通常取值 $0 < h < 1$。

*为什么要除以 $Delta t$？*

残差的量纲是*米*，而速度的量纲是*米/秒*。除以 $Delta t$ 完成单位转换：
$ ("位置误差") / ("时间间隔") approx "速度误差" $

这个操作本质上是在估算："位置错了 5 米，速度应该调整多少才能在 1 秒内补偿这个误差？"

*示例*：选择 $h = 0.1$，$Delta t = 1$ 秒，修正后的速度估计为：
$ hat(v)_k = 20 + 0.1 / 1 times (-5) = 20 - 0.5 = 19.5 " 米/秒" $

#{
  set par(first-line-indent: 0pt)
  [*完整的更新过程*]
}

g-h 滤波器的一次完整迭代包括：

#set enum(indent: 2em)
1. *预测*：
    $ p_(p r e d) &= hat(p)_(k-1) + hat(v)_(k-1) Delta t \
      v_(p r e d) &= hat(v)_(k-1) $

2. *修正*（测量到达后）：
    $ hat(p)_k &= p_(p r e d) + g dot (z_k - p_(p r e d)) \
      hat(v)_k &= v_(p r e d) + h / (Delta t) dot (z_k - p_(p r e d)) $

==== $g$ 和 $h$ 的物理意义

增益系数的选择直接决定了滤波器的性能特性。

*$g$ 的作用：平滑性与响应速度的权衡*

- *$g$ 较小*（如 0.1）：对测量不敏感，输出平滑，但跟踪存在滞后

  适用场景：测量噪声大，系统变化缓慢（如匀速行驶的火车）
  
- *$g$ 较大*（如 0.8）：快速响应测量变化，但容易受噪声干扰

  适用场景：测量精度高，系统动态变化快（如高速赛车）

*$h$ 的作用：速度修正的激进程度*

- *$h$ 较小*（如 0.05）：速度调整保守，适合长期稳定的系统
- *$h$ 较大*（如 0.5）：速度调整激进，适合加速度变化频繁的系统

需要注意的是，g-h 滤波器的最大局限在于*需要手动调参*。不同系统、不同噪声水平需要不同的 $g$ 和 $h$，这往往需要大量试错。

==== 从标量到矩阵：为高维系统做准备

前面通过标量公式完整描述了 g-h 滤波器的工作原理。但在实际应用中，往往需要处理更复杂的系统：

*考虑以下场景的状态数量：*
- *一维运动*：$(p, v)$ — 2个状态
- *二维平面运动*：$(x, y, v_x, v_y)$ — 4个状态  
- *三维空间运动*：$(x, y, z, v_x, v_y, v_z)$ — 6个状态
- *加入加速度*：$(x, y, z, v_x, v_y, v_z, a_x, a_y, a_z)$ — 9个状态

如果继续用标量公式，二维系统就需要写4个方程，三维系统需要6个方程。更糟糕的是，这些方程的*结构完全相同*，只是作用在不同的变量上。

矩阵形式提供了统一的框架：*无论系统有多少个状态，公式形式都保持不变*。

===== 第一步：将标量组织成向量

回顾我们的两个修正公式：

$ hat(p)_k &= p_(p r e d) + g dot (z_k - p_(p r e d)) \
  hat(v)_k &= v_(p r e d) + h / (Delta t) dot (z_k - p_(p r e d)) $

观察它们的共同结构：
#align(center)[
  估计 = 预测 + 增益 × 残差
]

两个公式的唯一区别是*增益系数不同*（$g$ vs $h/Delta t$）。既然结构相同，可以将它们"打包"成向量形式：

$ vec(hat(p)_k, hat(v)_k) = vec(p_(p r e d), v_(p r e d)) + vec(g, h / (Delta t)) dot (z_k - p_(p r e d)) $

定义：

- *状态向量*：$bold(x)_k = mat(p_k, v_k)$

- *增益向量*：$bold(K) = mat(g, h / (Delta t))$

则上式可以简写为：

$ hat(bold(x))_k = bold(x)_(p r e d) + bold(K) dot (z_k - p_(p r e d)) $

#block(
  fill: rgb("#e8f4f8"),
  inset: 10pt,
  radius: 4pt,
  width: 100%,
)[
  *关键观察*：增益向量 $bold(K)$ 的每一行对应一个状态的修正规则。
  - 第一行 $g$：控制位置如何修正
  - 第二行 $h/Delta t$：控制速度如何修正
]

===== 第二步：处理"测量只有部分状态"的情况

现在遇到一个问题：残差计算中的 $p_(p r e d)$ 如何从状态向量 $bold(x)_(p r e d) = vec(p_(p r e d), v_(p r e d))$ 中提取？

问题的本质是：*GPS 只能测量位置，无法测量速度*。用数学语言说：
- 状态空间维度：2（位置 + 速度）
- 测量空间维度：1（仅位置）

需要一个映射，将状态空间投影到测量空间。这就是*观测矩阵（Observation Matrix）* $bold(H)$ 的作用。

对于"只测量位置"的情况：

$ bold(H) = mat(1, 0) $

它的作用是：

$ bold(H) bold(x)_(p r e d) = mat(1, 0) vec(p_(p r e d), v_(p r e d)) = 1 dot p_(p r e d) + 0 dot v_(p r e d) = p_(p r e d) $

*直观理解*：$bold(H)$ 就像一个"提取器"，从完整状态中提取出可测量的部分。

#block(
  fill: rgb("#f0f8ff"),
  inset: 10pt,
  radius: 4pt,
  width: 100%,
)[
  #{
  set par(first-line-indent: 0pt)
  [*为什么需要 $bold(H)$？*]
}
  
  
  对于更复杂的系统，观测矩阵变得必不可少：
  - *雷达测距*：只测量距离，不测量速度 → $bold(H) = mat(1, 0)$
  - *加速度计*：只测量加速度，不测量位置和速度 → $bold(H) = mat(0, 0, 1)$
  - *GPS+速度计*：同时测量位置和速度 → $bold(H) = mat(1, 0; 0, 1)$
]

===== 第三步：完整的矩阵形式

有了状态向量 $bold(x)$、增益向量 $bold(K)$ 和观测矩阵 $bold(H)$，可以将 g-h 滤波器写成完全统一的形式：

#align(center)[
  #block(
    fill: rgb("#fff4e6"),
    inset: 12pt,
    radius: 4pt,
    stroke: 1.5pt + rgb("#ff9800")
  )[
    $ hat(bold(x))_k = bold(x)_(p r e d) + bold(K) (z_k - bold(H) bold(x)_(p r e d)) $
  ]
]

*公式各部分的物理意义*：

#table(
  columns: (auto, 1fr),
  align: (center, left),
  inset: (8pt), 
  stroke:none,
  
  // --- 表格内容 ---
  
  [$bold(x)_(p r e d)$],
  [模型预测的状态。],

  [$bold(H) bold(x)_(p r e d)$],
  [预测状态对应的测量值（"如果状态是 $bold(x)_(p r e d)$，传感器应该读到什么"）。],

  [$z_k - bold(H) bold(x)_(p r e d)$],
  [测量残差（实际测量 $z_k$ vs 预期测量 $bold(H) bold(x)_(p r e d)$）。],

  [$bold(K)$],
  [决定多大程度上信任测量残差（即多大程度上校正预测值）。],

  [$hat(bold(x))_k$],
  [融合预测与测量后的最优状态估计。],
)


===== 验证：展开矩阵公式

为确保矩阵形式确实等价于标量公式，展开验证：

$ vec(hat(p)_k, hat(v)_k) &= vec(p_(p r e d), v_(p r e d)) + vec(g, h / (Delta t)) (z_k - mat(1, 0) vec(p_(p r e d), v_(p r e d))) \
&= vec(p_(p r e d), v_(p r e d)) + vec(g, h / (Delta t)) (z_k - p_(p r e d)) \
&= vec(p_(p r e d) + g(z_k - p_(p r e d)), v_(p r e d) + h / (Delta t)(z_k - p_(p r e d))) $

结果与标量公式完全一致！


===== 预测步骤的矩阵形式

为了完整性，预测步骤也可以用矩阵表示。回顾上一章定义的状态转移矩阵：

$ bold(F) = mat(1, Delta t; 0, 1) $

预测步骤写为：

$ bold(x)_(p r e d) = bold(F) hat(bold(x))_(k-1) $

展开验证：

$ vec(p_(p r e d), v_(p r e d)) = mat(1, Delta t; 0, 1) vec(hat(p)_(k-1), hat(v)_(k-1)) = vec(hat(p)_(k-1) + Delta t dot hat(v)_(k-1), hat(v)_(k-1)) $

正是我们的位置和速度预测公式！

==== 完整算法流程（矩阵形式）

#block(
  fill: rgb("#fff8e1"),
  inset: 12pt,
  radius: 4pt,
  stroke: 1pt + rgb("#ffa726")
)[
  *g-h 滤波器算法（矩阵形式）*
  
  *定义*：
  
  $ bold(x)_k = vec(p_k, v_k), quad bold(F) = mat(1, Delta t; 0, 1), quad bold(H) = mat(1, 0), quad bold(K) = vec(g, h / (Delta t)) $
  
  *输入*：上一时刻估计 $hat(bold(x))_(k-1)$，当前测量 $z_k$
  
  *步骤 1：预测*
  $ bold(x)_(p r e d) = bold(F) hat(bold(x))_(k-1) $

  *步骤 2：修正*
  $ hat(bold(x))_k = bold(x)_(p r e d) + bold(K) (z_k - bold(H) bold(x)_(p r e d)) $
  
  *输出*：当前时刻最优估计 $hat(bold(x))_k$
]


==== g-h 滤波器的局限性

g-h 滤波器已经具备了现代滤波器的基本结构：
$ "估计" = "预测" + "增益" times "残差" $

它唯一缺少的，是*自动计算最优增益*的机制。卡尔曼滤波正是通过以下两点解决了这个问题：
1. 通过*误差协方差矩阵 $bold(P)_k$* 量化估计的不确定性
2. 通过*最小化估计误差*的准则，动态推导出最优增益 $bold(K)_k$

下一章将揭开这一机制的数学原理，展示卡尔曼滤波如何将 g-h 滤波器的直观思想发展为完整的最优估计理论。

/*
== 一维卡尔曼滤波器

=== 问题建模

==== 系统模型
- 状态方程（System Model / State Equation）
- 观测方程（Measurement Model / Observation Equation）
- 过程噪声与测量噪声

==== 符号体系说明
- 状态变量 $x_k$
- 观测值 $z_k$
- 先验估计 $hat(x)_(k|k-1)$ 与后验估计 $hat(x)_(k|k)$
- 误差协方差 $P_(k|k-1)$ 与 $P_(k|k)$

=== 卡尔曼滤波的五个方程

==== 预测步骤（Prediction / Time Update）
- 状态预测方程
- 协方差预测方程
- 物理意义解释

==== 更新步骤（Update / Measurement Update）
- 卡尔曼增益计算
- 状态更新方程
- 协方差更新方程
- 信息融合机制

=== 算法流程总结
- 初始化
- 预测-更新循环
- 流程图示

=== 实例：恒定速度目标跟踪

==== 问题描述
- 一维直线运动
- 位置测量含噪声
- 目标：估计位置与速度

==== 状态空间建模
- 状态向量 $bold(x) = vec(s, v)^T$（位置、速度）
- 状态转移矩阵
- 观测矩阵

==== 参数设置与仿真
- 过程噪声协方差 $Q$
- 测量噪声协方差 $R$
- 仿真结果分析

==== 滤波性能评估
- 估计误差分析
- 与简单平均的对比
- 参数敏感性分析

== 扩展卡尔曼滤波（EKF）

=== 非线性系统的挑战
- 线性卡尔曼滤波的局限性
- 非线性系统示例

=== 泰勒展开与线性化

==== 一阶泰勒近似
- 雅可比矩阵（Jacobian Matrix）
- 线性化的几何意义

==== 局部线性化策略
- 在估计点处展开
- 线性化误差分析

=== EKF 算法推导

==== 预测步骤
- 非线性状态预测
- 雅可比矩阵 $F_k$ 的计算
- 协方差预测

==== 更新步骤
- 观测雅可比矩阵 $H_k$
- 卡尔曼增益
- 状态与协方差更新

=== 实例：雷达目标跟踪

==== 问题描述
- 极坐标观测系统（距离、角度）
- 直角坐标状态空间
- 非线性观测方程

==== 观测模型线性化
- 雅可比矩阵推导
- 线性化点的选择

==== 仿真实验
- 场景设置
- EKF 性能分析
- 与线性假设的对比

=== EKF 的局限性与改进方向
- 高度非线性系统中的失效
- Unscented Kalman Filter (UKF) 简介
- Particle Filter 简介

== 多维卡尔曼滤波器

=== 从标量到向量

==== 多维状态空间
- 状态向量 $bold(x)_k in bb(R)^n$
- 观测向量 $bold(z)_k in bb(R)^m$
- 矩阵形式的系统方程

==== 协方差矩阵
- 误差协方差矩阵 $bold(P)_k$
- 多变量不确定性的表示
- 协方差传播

=== 多维卡尔曼滤波方程组

==== 预测步骤
$
bold(hat(x))_(k|k-1) &= bold(F)_k bold(hat(x))_(k-1|k-1) + bold(B)_k bold(u)_k \
bold(P)_(k|k-1) &= bold(F)_k bold(P)_(k-1|k-1) bold(F)_k^T + bold(Q)_k
$

==== 更新步骤
$
bold(K)_k &= bold(P)_(k|k-1) bold(H)_k^T (bold(H)_k bold(P)_(k|k-1) bold(H)_k^T + bold(R)_k)^(-1) \
bold(hat(x))_(k|k) &= bold(hat(x))_(k|k-1) + bold(K)_k (bold(z)_k - bold(H)_k bold(hat(x))_(k|k-1)) \
bold(P)_(k|k) &= (bold(I) - bold(K)_k bold(H)_k) bold(P)_(k|k-1)
$

==== 符号说明
#table(
  columns: (auto, 1fr),
  align: (center, left),
  stroke: (x, y) => (
    top: if y == 0 { 1pt } else { 0pt },
    bottom: if y == 0 or y == 9 { 1pt } else { 0pt },
  ),
  inset: 8pt,
  
  [*符号*], [*含义*],
  
  [$bold(x)_k in bb(R)^n$], 
  [第 $k$ 时刻的系统状态向量（$n$ 维）],
  
  [$bold(z)_k in bb(R)^m$], 
  [第 $k$ 时刻的观测向量（$m$ 维）],
  
  [$bold(F)_k in bb(R)^(n times n)$], 
  [状态转移矩阵：描述系统动态特性],
  
  [$bold(H)_k in bb(R)^(m times n)$], 
  [观测矩阵：将状态空间映射到观测空间],
  
  [$bold(B)_k in bb(R)^(n times l)$], 
  [控制输入矩阵],
  
  [$bold(u)_k in bb(R)^l$], 
  [控制输入向量],
  
  [$bold(Q)_k in bb(R)^(n times n)$], 
  [过程噪声协方差矩阵],
  
  [$bold(R)_k in bb(R)^(m times m)$], 
  [测量噪声协方差矩阵],
  
  [$bold(P)_(k|k) in bb(R)^(n times n)$], 
  [后验误差协方差矩阵],
)

=== 实例：二维平面目标跟踪

==== 问题描述
- 二维平面运动（$x$-$y$ 坐标系）
- 状态：位置 + 速度（4 维状态向量）
- 观测：带噪声的位置测量

==== 状态空间模型

===== 状态向量定义
$
bold(x)_k = vec(x_k, dot(x)_k, y_k, dot(y)_k)
$

===== 状态转移矩阵（匀速运动模型）
$
bold(F) = mat(
  1, Delta t, 0, 0;
  0, 1, 0, 0;
  0, 0, 1, Delta t;
  0, 0, 0, 1
)
$

===== 观测矩阵
$
bold(H) = mat(
  1, 0, 0, 0;
  0, 0, 1, 0
)
$

==== 噪声协方差设置

===== 过程噪声建模
- 加速度不确定性
- 离散化白噪声加速度模型
- $bold(Q)$ 矩阵构造

===== 测量噪声建模
- 传感器精度
- $bold(R)$ 矩阵设置

==== 仿真实验

===== 场景设置
- 目标运动轨迹
- 采样频率
- 噪声水平

===== 滤波结果
- 位置估计精度
- 速度估计精度
- 轨迹可视化

===== 性能分析
- 均方根误差（RMSE）
- 估计不确定性椭圆
- 收敛性分析*/